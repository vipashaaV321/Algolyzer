/*! For license information please see main.c5ddd78f.chunk.js.LICENSE.txt */
(this.webpackJsonpalgolyzer=this.webpackJsonpalgolyzer||[]).push([[0],{228:function(e,t,a){e.exports=a.p+"static/media/tsp.cbe4659f.jpg"},231:function(e,t,a){e.exports=a(657)},237:function(e,t,a){},238:function(e,t,a){},39:function(e,t){function a(e,t){var a=parseInt(e.slice(1,3),16),l=parseInt(e.slice(3,5),16),n=parseInt(e.slice(5,7),16);return t?"rgba("+a+", "+l+", "+n+", "+t+")":"rgb("+a+", "+l+", "+n+")"}var l={data:function(e){var t=e.getContext("2d"),a=t.createLinearGradient(500,0,100,0);a.addColorStop(0,"#80b6f4"),a.addColorStop(1,"#FFFFFF");var l=t.createLinearGradient(0,170,0,50);return l.addColorStop(0,"rgba(128, 182, 244, 0)"),l.addColorStop(1,"rgba(249, 99, 59, 0.40)"),{labels:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],datasets:[{label:"Active Users",borderColor:"#f96332",pointBorderColor:"#FFF",pointBackgroundColor:"#f96332",pointBorderWidth:2,pointHoverRadius:4,pointHoverBorderWidth:1,pointRadius:4,fill:!0,backgroundColor:l,borderWidth:2,data:[542,480,430,550,530,453,380,434,568,610,700,630]}]}},options:{maintainAspectRatio:!1,legend:{display:!1},tooltips:{bodySpacing:4,mode:"nearest",intersect:0,position:"nearest",xPadding:10,yPadding:10,caretPadding:10},responsive:1,scales:{yAxes:[{display:0,ticks:{display:!1,maxTicksLimit:7},gridLines:{zeroLineColor:"transparent",drawTicks:!1,display:!1,drawBorder:!1}}],xAxes:[{display:0,ticks:{display:!1},gridLines:{zeroLineColor:"transparent",drawTicks:!1,display:!1,drawBorder:!1}}]},layout:{padding:{left:0,right:0,top:15,bottom:15}}}},n={data:function(e){var t=e.getContext("2d"),l=t.createLinearGradient(500,0,100,0);l.addColorStop(0,"#18ce0f"),l.addColorStop(1,"#FFFFFF");var n=t.createLinearGradient(0,170,0,50);return n.addColorStop(0,"rgba(128, 182, 244, 0)"),n.addColorStop(1,a("#18ce0f",.4)),{labels:["12pm,","3pm","6pm","9pm","12am","3am","6am","9am"],datasets:[{label:"Email Stats",borderColor:"#18ce0f",pointBorderColor:"#FFF",pointBackgroundColor:"#18ce0f",pointBorderWidth:2,pointHoverRadius:4,pointHoverBorderWidth:1,pointRadius:4,fill:!0,backgroundColor:n,borderWidth:2,data:[40,500,650,700,1200,1250,1300,1900]}]}},options:{maintainAspectRatio:!1,legend:{display:!1},tooltips:{bodySpacing:4,mode:"nearest",intersect:0,position:"nearest",xPadding:10,yPadding:10,caretPadding:10},responsive:1,scales:{yAxes:[{gridLines:{zeroLineColor:"transparent",drawBorder:!1},ticks:{maxTicksLimit:7}}],xAxes:[{display:0,ticks:{display:!1},gridLines:{zeroLineColor:"transparent",drawTicks:!1,display:!1,drawBorder:!1}}]},layout:{padding:{left:0,right:0,top:15,bottom:15}}}},r={data:function(e){var t=e.getContext("2d").createLinearGradient(0,170,0,50);return t.addColorStop(0,"rgba(128, 182, 244, 0)"),t.addColorStop(1,a("#2CA8FF",.6)),{labels:["January","February","March","April","May","June","July","August","September","October","November","December"],datasets:[{label:"Active Countries",backgroundColor:t,borderColor:"#2CA8FF",pointBorderColor:"#FFF",pointBackgroundColor:"#2CA8FF",pointBorderWidth:2,pointHoverRadius:4,pointHoverBorderWidth:1,pointRadius:4,fill:!0,borderWidth:1,data:[80,99,86,96,123,85,100,75,88,90,123,155]}]}},options:{maintainAspectRatio:!1,legend:{display:!1},tooltips:{bodySpacing:4,mode:"nearest",intersect:0,position:"nearest",xPadding:10,yPadding:10,caretPadding:10},responsive:1,scales:{yAxes:[{ticks:{maxTicksLimit:7},gridLines:{zeroLineColor:"transparent",drawBorder:!1}}],xAxes:[{display:0,ticks:{display:!1},gridLines:{zeroLineColor:"transparent",drawTicks:!1,display:!1,drawBorder:!1}}]},layout:{padding:{left:0,right:0,top:15,bottom:15}}}};e.exports={dashboardPanelChart:{data:function(e){var t=e.getContext("2d"),a=t.createLinearGradient(500,0,100,0);a.addColorStop(0,"#80b6f4"),a.addColorStop(1,"#FFFFFF");var l=t.createLinearGradient(0,200,0,50);return l.addColorStop(0,"rgba(128, 182, 244, 0)"),l.addColorStop(1,"rgba(255, 255, 255, 0.14)"),{labels:["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"],datasets:[{label:"Data",borderColor:"#FFFFFF",pointBorderColor:"#FFFFFF",pointBackgroundColor:"#2c2c2c",pointHoverBackgroundColor:"#2c2c2c",pointHoverBorderColor:"#FFFFFF",pointBorderWidth:1,pointHoverRadius:7,pointHoverBorderWidth:2,pointRadius:5,fill:!0,backgroundColor:l,borderWidth:2,data:[50,150,100,190,130,90,150,160,120,140,190,95]}]}},options:{layout:{padding:{left:20,right:20,top:0,bottom:0}},maintainAspectRatio:!1,tooltips:{backgroundColor:"#fff",titleFontColor:"#333",bodyFontColor:"#666",bodySpacing:4,xPadding:12,mode:"nearest",intersect:0,position:"nearest"},legend:{position:"bottom",fillStyle:"#FFF",display:!1},scales:{yAxes:[{ticks:{fontColor:"rgba(255,255,255,0.4)",fontStyle:"bold",beginAtZero:!0,maxTicksLimit:5,padding:10},gridLines:{drawTicks:!0,drawBorder:!1,display:!0,color:"rgba(255,255,255,0.1)",zeroLineColor:"transparent"}}],xAxes:[{gridLines:{display:!1,color:"rgba(255,255,255,0.1)"},ticks:{padding:10,fontColor:"rgba(255,255,255,0.4)",fontStyle:"bold"}}]}}},dashboardShippedProductsChart:l,dashboardAllProductsChart:n,dashboard24HoursPerformanceChart:r}},465:function(e,t,a){e.exports=a.p+"static/media/bg5.056eb058.jpg"},466:function(e,t,a){e.exports=a.p+"static/media/mike.aab414f7.jpg"},657:function(e,t,a){"use strict";a.r(t);var l,n,r=a(0),i=a.n(r),o=a(34),s=a.n(o),c=a(36),m=a(18),u=(a(236),a(237),a(238),a(11)),h=a(12),d=a(14),E=a(13),p=a(97),g=a(177),b=a(176),f=a(178),y=a(180),A=a(96),v=a(72),w=a(152),x=a(153),k=a(154),T=a(155),N=a(156),I=a(157),C=a(218),S=a(158),B=a(165),M=a(166),P=a(167),O=a(168),j=a(169),D=a(170),q=a(171),z=a(57),F=a(172),G=function(e){Object(d.a)(a,e);var t=Object(E.a)(a);function a(){return Object(u.a)(this,a),t.apply(this,arguments)}return Object(h.a)(a,[{key:"render",value:function(){return i.a.createElement("div",{className:"panel-header "+(void 0!==this.props.size?"panel-header-"+this.props.size:"")})}}]),a}(i.a.Component),R=a(39),H=(i.a.Component,a(47)),W=a(223),K=a.n(W),L=a(95),Z=(i.a.Component,function(e){Object(d.a)(a,e);var t=Object(E.a)(a);function a(){return Object(u.a)(this,a),t.apply(this,arguments)}return Object(h.a)(a,[{key:"render",value:function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Basics Of Algorithm and Mathematics"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:8},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"An Algorithm is a sequence of steps to solve a problem."),i.a.createElement("li",null,"Design and Analysis of Algorithm is very important for designing algorithm to solve different types of problems in the branch of computer science and information technology. fundamental concepts ..Complexity analysis of Algorithms, followed by problems on Graph Theory and Sorting methods.")))))),i.a.createElement(x.a,{md:4},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRhGIr-NSJh7jkPA9fqGw9XWlWJGr1oi86bOQ&usqp=CAU",className:"mx-auto img-fluid"})))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Algorithm Design")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"The important aspects of algorithm design include creating an efficient algorithm to solve a problem in an efficient way using minimum time and space."),i.a.createElement("li",null,"To solve a problem, different approaches can be followed. Some of them can be efficient with respect to time consumption, whereas other approaches may be memory efficient. However, one has to keep in mind that both time consumption and memory usage cannot be optimized simultaneously. If we require an algorithm to run in lesser time, we have to invest in more memory and if we require an algorithm to run with lesser memory, we need to have more time."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Problem Development Steps")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Problem definition"),i.a.createElement("li",null,"Development of a model"),i.a.createElement("li",null,"Specification of an Algorithm"),i.a.createElement("li",null,"Designing an Algorithm"),i.a.createElement("li",null,"Checking the correctness of an Algorithm"),i.a.createElement("li",null,"Analysis of an Algorithm"),i.a.createElement("li",null,"Implementation of an Algorithm"),i.a.createElement("li",null,"Program testing"))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Characteristics of Algorithms")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Algorithms must have a unique name"),i.a.createElement("li",null,"Algorithms should have explicitly defined set of inputs and outputs"),i.a.createElement("li",null,"Algorithms are well-ordered with unambiguous operations"),i.a.createElement("li",null,"Algorithms halt in a finite amount of time. Algorithms should not run for infinity, i.e., an algorithm must end at some point"))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Pseudocode")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Pseudocode gives a high-level description of an algorithm without the ambiguity associated with plain text but also without the need to know the syntax of a particular programming language."),i.a.createElement("li",null,"The running time can be estimated in a more general manner by using Pseudocode to represent the algorithm as a set of fundamental operations which can then be counted."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Difference between Algorithm and Pseudocode")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,'An algorithm is a formal definition with some specific characteristics that describes a process, which could be executed by a Turing-complete computer machine to perform a specific task. Generally, the word "algorithm" can be used to describe any high level task in computer science.'),i.a.createElement("li",null,"On the other hand, pseudocode is an informal and (often rudimentary) human readable description of an algorithm leaving many granular details of it. Writing a pseudocode has no restriction of styles and its only objective is to describe the high level steps of algorithm in a much realistic manner in natural language."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Example of Algorithm")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("code",null,i.a.createElement("ul",null,i.a.createElement("li",null,"Algorithm: Insertion-Sort ",i.a.createElement("br",null)),i.a.createElement("li",null,"Input: A list L of integers of length n  ",i.a.createElement("br",null)),i.a.createElement("li",null,"Output: A sorted list L1 containing those integers present in L ",i.a.createElement("br",null)),i.a.createElement("li",null,"Step 1: Keep a sorted list L1 which starts off empty  ",i.a.createElement("br",null)),i.a.createElement("li",null,"Step 2: Perform Step 3 for each element in the original list L ",i.a.createElement("br",null)),i.a.createElement("li",null,"Step 3: Insert it into the correct position in the sorted list L1. ",i.a.createElement("br",null)),i.a.createElement("li",null,"Step 4: Return the sorted list ",i.a.createElement("br",null)),i.a.createElement("li",null,"Step 5: Stop")))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Example Of Pseudocode")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("code",null,i.a.createElement("ul",null,i.a.createElement("li",null,"for i "," <-"," 1 to length(A) ",i.a.createElement("br",null)),i.a.createElement("li",null,"x "," <-"," A[i] ",i.a.createElement("br",null)),i.a.createElement("li",null,"j "," <-"," i ",i.a.createElement("br",null)),i.a.createElement("li",null,"while j "," >"," 0 and A[j-1] "," >"," x ",i.a.createElement("br",null)),i.a.createElement("li",null,"A[j] "," <-"," A[j-1] ",i.a.createElement("br",null)),i.a.createElement("li",null,"A[j] "," <-"," A[j-1] ",i.a.createElement("br",null)),i.a.createElement("li",null,"j "," <-","j - 1 ",i.a.createElement("br",null)),i.a.createElement("li",null,"A[j] "," <-"," x",i.a.createElement("br",null)))))))))))}}]),a}(i.a.Component)),Q=(i.a.Component,["Name","Country","City","Salary"]),J=[{className:"table-success",data:["Dakota Rice","Niger","Oud-Turnhout","$36,738"]},{className:"",data:["Minerva Hooper","Cura\xe7ao","Sinaai-Waas","$23,789"]},{className:"table-info",data:["Sage Rodriguez","Netherlands","Baileux","$56,142"]},{className:"",data:["Philip Chaney","Korea, South","Overland Park","$38,735"]},{className:"table-danger",data:["Doris Greene","Malawi","Feldkirchen in K\xe4rnten","$63,542"]},{className:"",data:["Mason Porter","Chile","Gloucester","$78,615"]},{className:"table-warning",data:["Jon Porter","Portugal","Gloucester","$98,615"]}],V=(i.a.Component,a(73)),U=Object(V.withScriptjs)(Object(V.withGoogleMap)((function(e){return i.a.createElement(V.GoogleMap,{defaultZoom:13,defaultCenter:{lat:40.748817,lng:-73.985428},defaultOptions:{scrollwheel:!1,styles:[{featureType:"water",elementType:"geometry",stylers:[{color:"#e9e9e9"},{lightness:17}]},{featureType:"landscape",elementType:"geometry",stylers:[{color:"#f5f5f5"},{lightness:20}]},{featureType:"road.highway",elementType:"geometry.fill",stylers:[{color:"#ffffff"},{lightness:17}]},{featureType:"road.highway",elementType:"geometry.stroke",stylers:[{color:"#ffffff"},{lightness:29},{weight:.2}]},{featureType:"road.arterial",elementType:"geometry",stylers:[{color:"#ffffff"},{lightness:18}]},{featureType:"road.local",elementType:"geometry",stylers:[{color:"#ffffff"},{lightness:16}]},{featureType:"poi",elementType:"geometry",stylers:[{color:"#f5f5f5"},{lightness:21}]},{featureType:"poi.park",elementType:"geometry",stylers:[{color:"#dedede"},{lightness:21}]},{elementType:"labels.text.stroke",stylers:[{visibility:"on"},{color:"#ffffff"},{lightness:16}]},{elementType:"labels.text.fill",stylers:[{saturation:36},{color:"#333333"},{lightness:40}]},{elementType:"labels.icon",stylers:[{visibility:"off"}]},{featureType:"transit",elementType:"geometry",stylers:[{color:"#f2f2f2"},{lightness:19}]},{featureType:"administrative",elementType:"geometry.fill",stylers:[{color:"#fefefe"},{lightness:20}]},{featureType:"administrative",elementType:"geometry.stroke",stylers:[{color:"#fefefe"},{lightness:17},{weight:1.2}]}]}},i.a.createElement(V.Marker,{position:{lat:40.748817,lng:-73.985428}}))}))),Y=(i.a.Component,r.Component,a(182)),X=(i.a.Component,a(229)),_=a(179),$=function(){var e=Object(r.useState)(!1),t=Object(X.a)(e,2);t[0],t[1];return i.a.createElement(i.a.Fragment,null,i.a.createElement(g.a,{dark:!0,expand:"md",style:{backgroundColor:"#668cff"}},i.a.createElement(f.a,{href:"/",style:{color:"#fff"}},"Algolyzer"),i.a.createElement(_.a,{style:{marginLeft:"auto"}},"  ",i.a.createElement(c.b,{to:"Algolyzer"}," Go to Tutorials"))),i.a.createElement("section",{id:"header",className:"d-flex align-items-center"},i.a.createElement("div",{className:"container-fluid nav_bg"},i.a.createElement("div",{className:"row"},i.a.createElement("div",{className:"col-10 mx-auto"},i.a.createElement("div",{className:"row"},i.a.createElement("div",{class:"col-lg-6 order-2 order-lg-1 header-img"},i.a.createElement("img",{src:"https://i.pinimg.com/564x/ac/5e/ca/ac5ecadbed61d81f917b22c84796f218.jpg",className:"img-fluid animated",alt:"home-img"})),i.a.createElement("div",{className:"col-lg-6 pt-3 pt-lg-5 order-1 order-lg-2 d-flex justify-content-center flex-column text-center"},i.a.createElement("h1",null,i.a.createElement("strong",{className:"brand-name text-center"},"Algolyzer")," "),i.a.createElement("h5",null,i.a.createElement("strong",{className:"brand-name text-center"},"Learn Algorithms, Analyze Algorithms..")),i.a.createElement("h6",{className:"my-3"},"A portal for Engineering & Computer Science Students,tech enthusiast, competitive exam Aspirants"),i.a.createElement("div",{className:"mt-3"},i.a.createElement(c.b,{to:"Algolyzer",className:"btn btn-lg",id:"b",style:{backgroundColor:"#668cff",color:"#fff",borderRadius:"30px",paddingLeft:"30px",paddingRight:"30px",marginBottom:"10px"}}," Go to Tutorials")))))))))},ee=a(10),te=a.n(ee),ae=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Analysis of Algorithms"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Algorithm analysis is an important part of computational complexity theory, which provides theoretical estimation for the required resources of an algorithm to solve a specific computational problem. Most algorithms are designed to work with inputs of arbitrary length. Analysis of algorithms is the determination of the amount of time and space resources required to execute it. Usually, the efficiency or running time of an algorithm is stated as a function relating the input length to the number of steps, known as time complexity, or volume of memory, known as space complexit"))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Needs")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Algorithms are often quite different from one another, though the objective of these algorithms are the same. For example, we know that a set of numbers can be sorted using different algorithms. Number of comparisons performed by one algorithm may vary with others for the same input. Hence, time complexity of those algorithms may differ. At the same time, we need to calculate the memory space required by each algorithm. Analysis of algorithm is the process of analyzing the problem-solving capability of the algorithm in terms of the time and size required (the size of memory for storage while implementation). However, the main concern of analysis of algorithms is the required time or performance."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Types Of Analysis")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:8},i.a.createElement("ul",null,i.a.createElement("li",null,"Worst-case \u2212 The maximum number of steps taken on any instance of size a.",i.a.createElement("br",null),"For 'n' input size, the worst-case time complexity can be defined as the maximum amount of time needed by an algorithm to complete its execution. Thus, it is nothing but a function defined by the maximum number of steps performed on an instance having an input size of n."),i.a.createElement("li",null,"Average case \u2212 An average number of steps taken on any instance of size a.",i.a.createElement("br",null),"Average case time complexity is For 'n' input size, the average-case time complexity can be defined as the average amount of time needed by an algorithm to complete its execution. Thus, it is nothing but a function defined by the average number of steps performed on an instance having an input size of n."),i.a.createElement("li",null,"Best case time complexity: For 'n' input size, the best-case time complexity can be defined as the minimum amount of time needed by an algorithm to complete its execution. Thus, it is nothing but a function defined by the minimum number of steps performed on an instance having an input size of n."))),i.a.createElement(x.a,{md:4},i.a.createElement("img",{src:"https://static.javatpoint.com/tutorial/daa/images/daa-tutorial.png",style:{width:"300px",height:"300px"},className:"mx-auto my-2"}))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Let's understand More")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"there is a problem P1, then it may have many solutions, such that each of these solutions is regarded as an algorithm. So, there may be many algorithms such as A1, A2, A3, \u2026, An.",i.a.createElement("br",null),i.a.createElement("br",null),"Before you implement any algorithm as a program, it is better to find out which among these algorithms are good in terms of time and memory.",i.a.createElement("br",null),i.a.createElement("br",null),"It would be best to analyze every algorithm in terms of Time that relates to which one could execute faster and Memory corresponding to which one will take less memory.",i.a.createElement("br",null),i.a.createElement("br",null),"So, the Design and Analysis of Algorithm talks about how to design various algorithms and how to analyze them. After designing and analyzing, choose the best algorithm that takes the least time and the least memory and then implement it as a program in C.",i.a.createElement("br",null),i.a.createElement("br",null),"In this course, we will be focusing more on time rather than space because time is instead a more limiting parameter in terms of the hardware. It is not easy to take a computer and change its speed. So, if we are running an algorithm on a particular platform, we are more or less stuck with the performance that platform can give us in terms of speed.",i.a.createElement("br",null),i.a.createElement("br",null),"However, on the other hand, memory is relatively more flexible. We can increase the memory as when required by simply adding a memory card. So, we will focus on time than that of the space.",i.a.createElement("br",null)))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Methodology")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("strong",null," Asymptotic Analysis: "),"The asymptotic behavior of a function f(n) refers to the growth of f(n) as n gets large. We typically ignore small values of n, since we are usually interested in estimating how slow the program will be on large inputs. A good rule of thumb is that the slower the asymptotic growth rate, the better the algorithm. Though it\u2019s not always true. For example, a linear algorithm f(n)=d\u2217n+k is always asymptotically better than a quadratic one, f(n)=c.n2+q."),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("strong",null,"Solving Recurrence Equations : "),"A recurrence is an equation or inequality that describes a function in terms of its value on smaller inputs. Recurrences are generally used in divide-and-conquer paradigm. Let us consider T(n) to be the running time on a problem of size n. If the problem size is small enough, say n ","<"," c where c is a constant ",","," the straightforward solution takes constant time, which is written as \u03b8(1). If the division of the problem yields a number of sub-problems with size nb. To solve the problem, the required time is a.T(n/b). If we consider the time required for division is D(n) and the time required for combining the results of sub-problems is C(n), the recurrence relation can be represented as \u2212"," T(n)={\u03b8(1)aT(nb)+D(n)+C(n)ifn\u2a7dc ","otherwise"),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("strong",null,"Amortized Analysis :"),"Amortized analysis is generally used for certain algorithms where a sequence of similar operations are performed.",i.a.createElement("ul",null,i.a.createElement("li",null,"Amortized analysis provides a bound on the actual cost of the entire sequence, instead of bounding the cost of sequence of operations separately."),i.a.createElement("li",null,"Amortized analysis differs from average-case analysis; probability is not involved in amortized analysis. Amortized analysis guarantees the average performance of each operation in the worst case."),i.a.createElement("li",null,"It is not just a tool for analysis, it\u2019s a way of thinking about the design, since designing and analysis are closely related"))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Different Methods Of Amortized Analysis")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Aggregate Method The aggregate method gives a global view of a problem. In this method, if n operations takes worst-case time T(n) in total. Then the amortized cost of each operation is T(n)/n. Though different operations may take different time, in this method varying cost is neglected."),i.a.createElement("li",null,"Accounting Method In this method, different charges are assigned to different operations according to their actual cost. If the amortized cost of an operation exceeds its actual cost, the difference is assigned to the object as credit. This credit helps to pay for later operations for which the amortized cost less than actual cost"),i.a.createElement("li",null,"If the actual cost and the amortized cost of ith operation are ci and cl^, then \u2211i=1ncl^\u2a7e\u2211i=1nci",i.a.createElement("br",null),"Potential Method",i.a.createElement("br",null),"This method represents the prepaid work as potential energy, instead of considering prepaid work as credit. This energy can be released to pay for future operations."),i.a.createElement("li",null,"If we perform n operations starting with an initial data structure D0. Let us consider, ci as the actual cost and Di as data structure of ith operation. The potential function \u0424 maps to a real number \u0424(Di), the associated potential of Di. The amortized cost cl^ can be defined by"),i.a.createElement("li",null,"cl^=ci+\u03a6(Di)\u2212\u03a6(Di\u22121)",i.a.createElement("br",null),"Hence, the total amortized cost is",i.a.createElement("br",null),"\u2211i=1ncl^=\u2211i=1n(ci+\u03a6(Di)\u2212\u03a6(Di\u22121))=\u2211i=1nci+\u03a6(Dn)\u2212\u03a6(D0)"),i.a.createElement("li",null,"Dynamic Table",i.a.createElement("br",null),"If the allocated space for the table is not enough, we must copy the table into larger size table. Similarly, if large number of members are erased from the table, it is a good idea to reallocate the table with a smaller size.",i.a.createElement("br",null),"Using amortized analysis, we can show that the amortized cost of insertion and deletion is constant and unused space in a dynamic table never exceeds a constant fraction of the total space.")))))))))},le=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Asymptotic Notations and Apriori Analysis"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"complexity analysis of an algorithm is an essential aspect. Mainly, algorithmic complexity is concerned about its performance, how fast or slow it works.",i.a.createElement("br",null),"The complexity of an algorithm describes the efficiency of the algorithm in terms of the amount of the memory required to process the data and the processing time.",i.a.createElement("br",null),"Complexity of an algorithm is analyzed in two perspectives: Time and Space."),i.a.createElement("li",null,"The term algorithm complexity measures how many steps are required by the algorithm to solve the given problem. It evaluates the order of count of operations executed by an algorithm as a function of input data size.",i.a.createElement("br",null),"To assess the complexity, the order (approximation) of the count of operation is always considered instead of counting the exact steps.",i.a.createElement("br",null),'O(f) notation represents the complexity of an algorithm, which is also termed as an Asymptotic notation or "Big O" notation. Here the f corresponds to the function whose size is the same as that of the input data. The complexity of the asymptotic computation O(f) determines in which order the resources such as CPU time, memory, etc. are consumed by the algorithm that is articulated as a function of the size of the input data.'))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Typical Complexities of an Algorithm")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Constant Complexity: It imposes a complexity of O(1). It undergoes an execution of a constant number of steps like 1, 5, 10, etc. for solving a given problem. The count of operations is independent of the input data size."),i.a.createElement("li",null,"Logarithmic Complexity: It imposes a complexity of O(log(N)). It undergoes the execution of the order of log(N) steps. To perform operations on N elements, it often takes the logarithmic base as 2. For N = 1,000,000, an algorithm that has a complexity of O(log(N)) would undergo 20 steps (with a constant precision). Here, the logarithmic base does not hold a necessary consequence for the operation count order, so it is usually omitted."),i.a.createElement("li",null,"Linear Complexity: It imposes a complexity of O(N). It encompasses the same number of steps as that of the total number of elements to implement an operation on N elements. For example, if there exist 500 elements, then it will take about 500 steps. Basically, in linear complexity, the number of elements linearly depends on the number of steps. For example, the number of steps for N elements can be N/2 or 3*N. It also imposes a run time of O(n*log(n)). It undergoes the execution of the order N*log(N) on N number of elements to solve the given problem. For a given 1000 elements, the linear complexity will execute 10,000 steps for solving a given problem."),i.a.createElement("li",null,"Quadratic Complexity: It imposes a complexity of O(n2). For N input data size, it undergoes the order of N2 count of operations on N number of elements for solving a given problem. If N = 100, it will endure 10,000 steps. In other words, whenever the order of operation tends to have a quadratic relation with the input data size, it results in quadratic complexity. For example, for N number of elements, the steps are found to be in the order of 3*N2/2. Cubic Complexity: It imposes a complexity of O(n3). For N input data size, it executes the order of N3 steps on N elements to solve a given problem. For example, if there exist 100 elements, it is going to execute 1,000,000 steps."),i.a.createElement("li",null,"Exponential Complexity: It imposes a complexity of O(2n), O(N!), O(nk), \u2026. For N elements, it will execute the order of count of operations that is exponentially dependable on the input data size. For example, if N = 10, then the exponential function 2N will result in 1024. Similarly, if N = 20, it will result in 1048 576, and if N = 100, it will result in a number having 30 digits. The exponential function N! grows even faster; for example, if N = 5 will result in 120. Likewise, if N = 10, it will result in 3,628,800 and so on. Since the constants do not hold a significant effect on the order of count of operation, so it is better to ignore them. Thus, to consider an algorithm to be linear and equally efficient, it must undergo N, N/2 or 3*N count of operation, respectively, on the same number of elements to solve a particular problem."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Types Of Complexities")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:8},i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("strong",null,"   Time Complexity"),i.a.createElement("br",null),'It\u2019s a function describing the amount of time required to run an algorithm in terms of the size of the input. "Time" can mean the number of memory accesses performed, the number of comparisons between integers, the number of times some inner loop is executed, or some other natural unit related to the amount of real time the algorithm will take.'),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("strong",null,"        Space Complexity"),i.a.createElement("br",null),'It\u2019s a function describing the amount of memory an algorithm takes in terms of the size of input to the algorithm. We often speak of "extra" memory needed, not counting the memory needed to store the input itself. Again, we use natural (but fixed-length) units to measure this. Space complexity is sometimes ignored because the space used is minimal and/or obvious, however sometimes it becomes as important an issue as time.'))),i.a.createElement(x.a,{md:4},i.a.createElement("img",{src:"https://i.pinimg.com/474x/54/30/4b/54304beac68bbed7fc5b376dfd8e006a.jpg",style:{width:"300px",height:"300px"},className:"mx-auto my-2"}))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Let's understand More")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("p",null,"Execution time of an algorithm depends on the instruction set, processor speed, disk I/O speed, etc. Hence, we estimate the efficiency of an algorithm asymptotically."),i.a.createElement("p",null,"Time function of an algorithm is represented by ",i.a.createElement("b",null,"T(n)"),", where ",i.a.createElement("b",null,"n")," is the input size."),i.a.createElement("p",null,"Different types of asymptotic notations are used to represent the complexity of an algorithm. Following asymptotic notations are used to calculate the running time complexity of an algorithm."),i.a.createElement("ul",{className:"list"},i.a.createElement("li",null,i.a.createElement("p",null,i.a.createElement("b",null,"O")," \u2212 Big Oh")),i.a.createElement("li",null,i.a.createElement("p",null,i.a.createElement("b",null,"\u03a9")," \u2212 Big omega")),i.a.createElement("li",null,i.a.createElement("p",null,i.a.createElement("b",null,"\u03b8")," \u2212 Big theta")),i.a.createElement("li",null,i.a.createElement("p",null,i.a.createElement("b",null,"o")," \u2212 Little Oh")),i.a.createElement("li",null,i.a.createElement("p",null,i.a.createElement("b",null,"\u03c9")," \u2212 Little omega")))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Asymptotic Analysis of algorithms (Growth of function)")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("p",null,"Resources for an algorithm are usually expressed as a function regarding input. Often this function is messy and complicated to work. To study Function growth efficiently, we reduce the function down to the important part."),i.a.createElement("div",{class:"codeblock"},i.a.createElement("pre",null,"Let f (n) = an",i.a.createElement("sup",null,"2"),"+bn+c")),"  ",i.a.createElement("br",null),i.a.createElement("p",null,"In this function, the n",i.a.createElement("sup",null,"2")," term dominates the function that is when n gets sufficiently large."),i.a.createElement("p",null,"Dominate terms are what we are interested in reducing a function, in this; we ignore all constants and coefficient and look at the highest order term concerning n."))),i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("h6",null,"Asymptotic notation:"),i.a.createElement("p",null,"The word ",i.a.createElement("strong",null,"Asymptotic")," means approaching a value or curve arbitrarily closely (i.e., as some sort of limit is taken).")),i.a.createElement("li",null,i.a.createElement("h6",null,"Asymptotic analysis"),i.a.createElement("p",null,"It is a technique of representing limiting behavior. The methodology has the applications across science. It can be used to analyze the performance of an algorithm for some large data set. "),i.a.createElement("p",null,"1. In computer science in the analysis of algorithms, considering the performance of algorithms when applied to very large input datasets "),i.a.createElement("p",null,"The simplest example is a function ",i.a.createElement("em",null,"\u0192 (n) = n",i.a.createElement("sup",null,"2"),"+3n"),", the term 3n becomes insignificant compared to ",i.a.createElement("em",null,"n",i.a.createElement("sup",null,"2")),' when n is very large. The function "',i.a.createElement("em",null,"\u0192 (n)")," is said to be ",i.a.createElement("strong",null,"asymptotically equivalent")," to ",i.a.createElement("em",null,"n",i.a.createElement("sup",null,"2"))," as ",i.a.createElement("em",null,"n \u2192 \u221e"),'", and here is written symbolically as ',i.a.createElement("em",null,"\u0192 (n) ~ n",i.a.createElement("sup",null,"2")),".")),i.a.createElement("li",null,i.a.createElement("p",null,i.a.createElement("strong",null,"Asymptotic notations")," are used to write fastest and slowest possible running time for an algorithm. These are also referred to as 'best case' and 'worst case' scenarios respectively. "),i.a.createElement("p",null,'"In asymptotic notations, we derive the complexity concerning the size of the input. (Example in terms of n)"'),i.a.createElement("p",null,'"These notations are important because without expanding the cost of running the algorithm, we can estimate the complexity of the algorithms."')),i.a.createElement("li",null,i.a.createElement("h6",null,"Why is Asymptotic Notation Important?"),i.a.createElement("p",null,"1. They give simple characteristics of an algorithm's efficiency."),i.a.createElement("p",null,"2. They allow the comparisons of the performances of various algorithms."),i.a.createElement("h2",{class:"h2"},"Asymptotic Notations: "),i.a.createElement("p",null,"Asymptotic Notation is a way of comparing function that ignores constant factors and small input sizes. Three notations are used to calculate the running time complexity of an algorithm:"),i.a.createElement("p",null,i.a.createElement("strong",null,"1. Big-oh notation:")," Big-oh is the formal method of expressing the upper bound of an algorithm's running time. It is the measure of the longest amount of time. The function ",i.a.createElement("strong",null,"f (n) = O (g (n))"),' [read as "f of n is big-oh of g of n"] if and only if exist positive constant c and  such that'),i.a.createElement("div",{class:"codeblock"},"f (n) \u2a7d k.g (n)f(n)\u2a7dk.g(n) for n",">","n0n",">","n0 in all case"),i.a.createElement("p",null,"Hence, function g (n) is an upper bound for function f (n), as g (n) grows faster than f (n)")),i.a.createElement("li",null,i.a.createElement("img",{src:"https://static.javatpoint.com/tutorial/daa/images/daa-asymptotic-analysis-of-algorithm.png",alt:"DAA Asymptotic Analysis of algorithms",className:"mx-auto img-fluid"})),i.a.createElement("li",null,i.a.createElement("h6",null,"Example"),i.a.createElement("div",{class:"codeblock"},"1. 3n+2=O(n) as 3n+2\u22644n for all n\u22652 2. 3n+3=O(n) as 3n+3\u22644n for all n\u22653"),i.a.createElement("p",null,"Hence, the complexity of ",i.a.createElement("strong",null,"f(n)")," can be represented as O (g (n))"),i.a.createElement("p",null,i.a.createElement("strong",null,"2. Omega () Notation:"),' The function f (n) = \u2126 (g (n)) [read as "f of n is omega of g of n"] if and only if there exists positive constant c and n',i.a.createElement("sub",null,"0")," such that "),i.a.createElement("div",{class:"codeblock"},i.a.createElement("pre",null,"F (n) \u2265 k* g (n) for all n, n\u2265 n",i.a.createElement("sub",null,"0")))),i.a.createElement("li",null,i.a.createElement("img",{className:"mx-auto img-fluid",src:"https://static.javatpoint.com/tutorial/daa/images/daa-asymptotic-analysis-of-algorithm2.png",alt:"DAA Asymptotic Analysis of algorithms"})),i.a.createElement("li",null,i.a.createElement("div",{class:"codeblock"},i.a.createElement("pre",null,"f (n) =8n",i.a.createElement("sup",null,"2"),"+2n-3\u22658n",i.a.createElement("sup",null,"2"),"-3 =7n",i.a.createElement("sup",null,"2"),"+(n",i.a.createElement("sup",null,"2"),"-3)\u22657n",i.a.createElement("sup",null,"2")," (g(n)) Thus, k",i.a.createElement("sub",null,"1"),"=7"))),i.a.createElement("li",null,i.a.createElement("p",null,"Hence, the complexity of ",i.a.createElement("strong",null,"f (n)")," can be represented as \u2126 (g (n))"),i.a.createElement("p",null,i.a.createElement("strong",null,"3. Theta (\u03b8):"),' The function f (n) = \u03b8 (g (n)) [read as "f is the theta of g of n"] if and only if there exists positive constant k',i.a.createElement("sub",null,"1"),", k",i.a.createElement("sub",null,"2")," and k",i.a.createElement("sub",null,"0")," such that"),i.a.createElement("div",{class:"codeblock"},i.a.createElement("pre",null,"k",i.a.createElement("sub",null,"1")," * g (n) \u2264 f(n)\u2264 k",i.a.createElement("sub",null,"2")," g(n)for all n, n\u2265 n",i.a.createElement("sub",null,"0")))),i.a.createElement("li",null,i.a.createElement("img",{className:"mx-auto img-fluid",src:"https://static.javatpoint.com/tutorial/daa/images/daa-asymptotic-analysis-of-algorithm3.png",alt:"DAA Asymptotic Analysis of algorithms"})),i.a.createElement("li",null,i.a.createElement("div",{class:"codeblock"},i.a.createElement("pre",null,"3n+2= \u03b8 (n) as 3n+2\u22653n and 3n+2\u2264 4n, for n k",i.a.createElement("sub",null,"1"),"=3,k",i.a.createElement("sub",null,"2"),"=4, and n",i.a.createElement("sub",null,"0"),"=2")),i.a.createElement("p",null,"Hence, the complexity of f (n) can be represented as \u03b8 (g(n))."),i.a.createElement("p",null,"The Theta Notation is more precise than both the big-oh and Omega notation. The function f (n) = \u03b8 (g (n)) if g(n)  is both an upper and lower bound."))))))))))},ne=a(227),re=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Recurrence Relation"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"A recurrence is an equation or inequality that describes a function in terms of its values on smaller inputs. To solve a Recurrence Relation means to obtain a function defined on the natural numbers that satisfy the recurrence. For Example, the Worst Case Running Time T(n) of the MERGE SORT Procedures is described by the recurrence. T (n) = \u03b8 (1) if n=1 2T(n/2) Recurrence Relation + \u03b8 (n) if n",">","1"))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Four methods for solving Recurrence:")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ol",null,i.a.createElement("li",null,i.a.createElement("strong",null,"Substitution Method: "),"The Substitution Method Consists of two main steps:",i.a.createElement("br",null),"Use the mathematical induction to find the boundary condition and shows that the guess is correct. For Example1 Solve the equation by Substitution Method.",i.a.createElement("br",null),"T (n) = (n/2) Recurrence Relation + n We have to show that it is asymptotically bound by O (log n).",i.a.createElement("br",null),"Solution:",i.a.createElement("br",null),i.a.createElement("code",null,"For T (n) = O (log n)"),i.a.createElement("br",null),"We have to show that for some constant c ",i.a.createElement("br",null),i.a.createElement("code",null," T(n) \u2264c logn. "),i.a.createElement("br",null),"Put this in given Recurrence Equation.",i.a.createElement("code",null,i.a.createElement("br",null),"T (n) \u2264c log(n/2) Recurrence Relation+ 1",i.a.createElement("br",null),"\u2264c log(n/2) Recurrence Relation+ 1 = c logn-clog2 2+1",i.a.createElement("br",null),"\u2264c logn for c\u22651",i.a.createElement("br",null),"Thus T (n) =O logn.")),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("strong",null,"Iteration Methods:"),i.a.createElement("br",null),"It means to expand the recurrence and express it as a summation of terms of n and initial condition.",i.a.createElement("br",null),"Example1: Consider the Recurrence",i.a.createElement(te.a,null,"T (n) = 1  if n=1  ",i.a.createElement("br",null),"T (n) = 2T (n-1) if n",">","1  ",i.a.createElement("br",null),"Solution: T (n) = 2T (n-1)",i.a.createElement("br",null),"= 2[2T (n-2)] = 2^2T (n-2)",i.a.createElement("br",null),"= 4[2T (n-3)] = 2^3T (n-3)",i.a.createElement("br",null),"= 8[2T (n-4)] = 2^4T (n-4)   (Eq.1)",i.a.createElement("br",null),"Repeat the procedure for i times",i.a.createElement("br",null),"T (n) = 2i T (n-i)",i.a.createElement("br",null),"Put n-i=1 or i= n-1 in    (Eq.1)",i.a.createElement("br",null),"T (n) = 2n-1 T (1)",i.a.createElement("br",null),"= 2n-1 .1    [T (1) =1 .....given]",i.a.createElement("br",null),"= 2n-1 ",i.a.createElement("br",null))),i.a.createElement("li",null,i.a.createElement("strong",null,"Recursion Tree Method"),i.a.createElement("br",null),i.a.createElement("ol",null,i.a.createElement("li",null,"Recursion Tree Method is a pictorial representation of an iteration method which is in the form of a tree where at each level nodes are expanded."),i.a.createElement("li",null,"In general, we consider the second term in recurrence as root."),i.a.createElement("li",null,"It is useful when the divide & Conquer algorithm is used."),i.a.createElement("li",null,"It is sometimes difficult to come up with a good guess. In Recursion tree, each root and child represents the cost of a single subproblem"),i.a.createElement("li",null,"We sum the costs within each of the levels of the tree to obtain a set of pre-level costs and then sum all pre-level costs to determine the total cost of all levels of the recursion."),i.a.createElement("li",null,"A Recursion Tree is best used to generate a good guess, which can be verified by the Substitution Method.")),i.a.createElement(w.a,{className:"p-2"},i.a.createElement(x.a,{md:7},i.a.createElement("img",{src:"https://i.pinimg.com/474x/21/75/27/217527b19197de3d7cd5121d3bcbfd98.jpg",className:"responsive"})),i.a.createElement(x.a,{md:5},i.a.createElement("br",null),i.a.createElement("br",null),i.a.createElement("img",Object(ne.a)({className:"responsive",src:"data:image/png;base64,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"},"className","responsive"))))),i.a.createElement("li",null,i.a.createElement("strong",null,"Master Method"),i.a.createElement("br",null),"The Master Method is used for solving the following types of recurrence T (n) = a T(n/b) Master Method+ f (n) with a\u22651 and b\u22651 be constant & f(n) be a function and (n/b)  Master Methodcan be interpreted as Let T (n) is defined on non-negative integers by the recurrence."),i.a.createElement("p",null,"In the function to the analysis of a recursive algorithm, the constants and function take on the following significance:"),i.a.createElement("ul",{class:"points"},i.a.createElement("li",null,"n is the size of the problem. "),i.a.createElement("li",null,"a is the number of subproblems in the recursion.  "),i.a.createElement("li",null,"n/b is the size of each subproblem. (Here it is assumed that all subproblems are essentially the same size.)"),i.a.createElement("li",null,"f (n) is the sum of the work done outside the recursive calls, which includes the sum of dividing the problem and the sum of combining the solutions to the subproblems."),i.a.createElement("li",null,"It is not possible always bound the function according to the requirement, so we make three cases which will tell us what kind of bound we can apply on the function."),i.a.createElement("li",null,i.a.createElement("br",null),i.a.createElement("img",{src:"data:image/png;base64,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"})),i.a.createElement("br",null),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("strong",null,"Example"),i.a.createElement("br",null),i.a.createElement(te.a,null,"T(n) = 3T(n/2) + n2",i.a.createElement("br",null),"Here,",i.a.createElement("br",null),"a = 3",i.a.createElement("br",null),"n/b = n/2",i.a.createElement("br",null),"f(n) = n2",i.a.createElement("br",null),"logb a = log2 3 \u2248 1.58 ","<"," 2",i.a.createElement("br",null),"ie. f(n) ","<"," nlogb ","a+\u03f5"," , where, \u03f5 is a constant.",i.a.createElement("br",null),"Case 3 implies here.",i.a.createElement("br",null),"Thus, T(n) = f(n) = \u0398(n2)")))))))))))},ie=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Sorting Algorithms"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"A Sorting Algorithm is used to rearrange a given array or list elements according to a comparison operator on the elements. The comparison operator is used to decide the new order of element in the respective data structure."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Bubble Sort")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Bubble Sort also known as Exchange Sort, is a simple sorting algorithm. It works by repeatedly stepping throughout the list to be sorted, comparing two items at a time and swapping them if they are in the wrong order. The pass through the list is duplicated until no swaps are desired, which means the list is sorted.")),i.a.createElement(x.a,{md:6,className:"mx-auto ml-auto",style:{padding:"20px"}},i.a.createElement("img",{src:"https://www.opentechguides.com/images/howto/howto_5101.png",className:"mx-auto"})),i.a.createElement(x.a,{md:6},i.a.createElement("code",null,"Algorithm: Sequential-Bubble-Sort (A) ",i.a.createElement("br",null),"for i\u2190 1 to length [A] do ",i.a.createElement("br",null),"for j \u2190 length [A] down-to i +1 do ",i.a.createElement("br",null),"if A[A] ","<"," A[j - 1] then ",i.a.createElement("br",null),"Exchange A[j] \u2194 A[j-1]"),i.a.createElement("br",null),i.a.createElement("strong",{style:{margin:"10px"}},i.a.createElement("u",null,"Code")),i.a.createElement("br",null),i.a.createElement("p",null,i.a.createElement(te.a,null,"voidbubble(int numbers[],intarray_size) ",i.a.createElement("br",null),"{",i.a.createElement("br",null),"int i, j, temp",";",i.a.createElement("br",null),"for (i = (array_size - 1); i ",">","= 0; i--)","{"," ",i.a.createElement("br",null),"for (j = 1; j ","<","= i; j++)","{"," ",i.a.createElement("br",null),"if (numbers[j - 1] ",">"," numbers[j]) ","{"," ",i.a.createElement("br",null),"temp = numbers","[j-1]",";",i.a.createElement("br",null),"numbers[j - 1] = numbers[j];",i.a.createElement("br",null),"numbers[j] = temp; ",i.a.createElement("br",null),"}"," ","}"," ","}"," ","}"))),i.a.createElement("ul",null,i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("h6",null,"  Analysis"),i.a.createElement("br",null),"The number of comparisons are",i.a.createElement("br",null)),i.a.createElement("ul",null,i.a.createElement("li",null,"1 + 2 + 3 +...+ (n - 1) = n(n - 1)/2 = O(n",i.a.createElement("sup",null,"2"),")",i.a.createElement("br",null),"It shows the n",i.a.createElement("sup",null,"2")," nature of the bubble sort.",i.a.createElement("br",null),"In this algorithm, the number of comparison is irrespective of the data set, i.e. whether the provided input elements are in sorted order or in reverse order or at random.",i.a.createElement("br",null))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Insertion Sort")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"It is a very simple method to sort the number in an increasing or decreasing order."),i.a.createElement("li",null,"It has various advantages:"),i.a.createElement("li",null,"It is simple to implement."),i.a.createElement("li",null,"It is efficient on small datasets."),i.a.createElement("li",null,"It is stable (does not change the relative order of elements with equal keys)"),i.a.createElement("li",null,"It is in-place (only requires a constant amount O (1) of extra memory space)."),i.a.createElement("li",null,"It is an online algorithm, in that it can sort a list as it receives it."),i.a.createElement("li",null,"If the given numbers are sorted, this algorithm runs in O(n) time. If the given numbers are in reverse order, the algorithm runs in O(n2) time.")),i.a.createElement(x.a,{md:6},i.a.createElement("img",{src:"https://media.geeksforgeeks.org/wp-content/uploads/insertionsort.png",className:"img-fluid mx-auto",style:{height:"300px",width:"300px"}})),i.a.createElement(x.a,{md:6},i.a.createElement("code",{style:{fontSize:"22px"}},"Algorithm: Insertion-Sort(A) ",i.a.createElement("br",null),"for j = 2 to A.length ",i.a.createElement("br",null),"key = A[j] ",i.a.createElement("br",null),"i = j \u2013 1 ",i.a.createElement("br",null),"while i ",">"," 0 and A[i] ",">"," key ",i.a.createElement("br",null),"A[i + 1] = A[i] ",i.a.createElement("br",null),"i = i -1 ",i.a.createElement("br",null),"A[i + 1] = key ",i.a.createElement("br",null)))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Radix Sort")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Radix sort is a small method that many people intuitively use when alphabetizing a large list of names. Specifically, the list of names is first sorted according to the first letter of each name, that is, the names are arranged in 26 classes."),i.a.createElement("li",null,"Intuitively, one might want to sort numbers on their most significant digit. However, Radix sort works counter-intuitively by sorting on the least significant digits first. On the first pass, all the numbers are sorted on the least significant digit and combined in an array. Then on the second pass, the entire numbers are sorted again on the second least significant digits and combined in an array and so on."),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm: Radix-Sort (list, n) ",i.a.createElement("br",null),"shift = 1  ",i.a.createElement("br",null),"for loop = 1 to keysize do  ",i.a.createElement("br",null),"for entry = 1 to n do  ",i.a.createElement("br",null),"bucketnumber = (list[entry].key / shift) mod 10  ",i.a.createElement("br",null),"append (bucket[bucketnumber], list[entry])  ",i.a.createElement("br",null),"list = combinebuckets()  ",i.a.createElement("br",null),"shift = shift * 10  ",i.a.createElement("br",null))),i.a.createElement("li",null,"Analysis",i.a.createElement("ul",null,i.a.createElement("li",null,"Each key is looked at once for each digit (or letter if the keys are alphabetic) of the longest key. Hence, if the longest key has m digits and there are n keys, radix sort has order O(m.n)."),i.a.createElement("li",null,"However, if we look at these two values, the size of the keys will be relatively small when compared to the number of keys. For example, if we have six-digit keys, we could have a million different records."),i.a.createElement("li",null,"Here, we see that the size of the keys is not significant, and this algorithm is of linear complexity O(n)."))),i.a.createElement("li",null,"Original, unsorted list: 170, 45, 75, 90, 802, 24, 2, 66 Sorting by least significant digit (1s place) gives: [*Notice that we keep 802 before 2, because 802 occurred before 2 in the original list, and similarly for pairs 170 & 90 and 45 & 75.] Sorting by next digit (10s place) gives: [*Notice that 802 again comes before 2 as 802 comes before 2 in the previous list.] 802, 2, 24, 45, 66, 170, 75, 90 Sorting by the most significant digit (100s place) gives: 2, 24, 45, 66, 75, 90, 170, 802"),i.a.createElement("br",null)),i.a.createElement("img",{src:"https://www.codingeek.com/wp-content/uploads/2017/02/radix.png",className:"img-fluid mx-auto",style:{width:"100%",height:"350px"}})))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Counting Sort")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"It is a linear time sorting algorithm which works faster by not making a comparison. It assumes that the number to be sorted is in range 1 to k where k is small"),i.a.createElement("li",null,'Basic idea is to determine the "rank" of each number in the final sorted array.',i.a.createElement("ul",null,"Counting Sort uses three arrays:",i.a.createElement("li",null,"A [1, n] holds initial input."),i.a.createElement("li",null,"B [1, n] holds sorted output."),i.a.createElement("li",null,"C [1, k] is the array of integer. C [x] is the rank of x in A where x \u2208 [1, k]"))),i.a.createElement("li",null,"Firstly C [x] to be a number of elements of A [j] that is equal to x",i.a.createElement("li",null,"Initialize C to zero"),i.a.createElement("li",null,"For each j from 1 to n increment C [A[j]] by 1"),i.a.createElement("li",null,"We set B[C [x]] =A[j]"),i.a.createElement("li",null,"If there are duplicates, we decrement C [i] after copying."),i.a.createElement("li",null,i.a.createElement("img",{src:"https://4.bp.blogspot.com/-Vc4N7rlZ7xI/VR6h5JWeqyI/AAAAAAAAEPo/PTotACjg398/s1600/Counting%2BSort%2BAlgorithm.gif",className:"mx-auto img-fluid"})),i.a.createElement("li",null,i.a.createElement("code",null,"For simplicity, consider the data in the range 0 to 9. ",i.a.createElement("br",null),"Input data: 1, 4, 1, 2, 7, 5, 2",i.a.createElement("br",null),"1) Take a count array to store the count of each unique object.",i.a.createElement("br",null),"Index:     0  1  2  3  4  5  6  7  8  9",i.a.createElement("br",null),"Count:     0  2  2  0   1  1  0  1  0  0",i.a.createElement("br",null),"2) Modify the count array such that each element at each index ",i.a.createElement("br",null),"stores the sum of previous counts. ",i.a.createElement("br",null),"Index:     0  1  2  3  4  5  6  7  8  9",i.a.createElement("br",null),"Count:     0  2  4  4  5  6  6  7  7  7",i.a.createElement("br",null),"The modified count array indicates the position of each object in the output sequence.",i.a.createElement("br",null),"3) Output each object from the input sequence followed by decreasing its count by 1.",i.a.createElement("br",null),"Process the input data: 1, 4, 1, 2, 7, 5, 2. Position of 1 is 2.",i.a.createElement("br",null),"Put data 1 at index 2 in output. Decrease count by 1 to place ",i.a.createElement("br",null),"next data 1 at an index 1 smaller than this index.",i.a.createElement("br",null)))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Bucket Sort")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Bucket Sort runs in linear time on average. Like Counting Sort, bucket Sort is fast because it considers something about the input. Bucket Sort considers that the input is generated by a random process that distributes elements uniformly over the interval\u03bc=[0,1]."),i.a.createElement("li",null,"To sort n input numbers, Bucket Sort",i.a.createElement("ul",null,i.a.createElement("li",null,"Partition \u03bc into n non-overlapping intervals called buckets."),i.a.createElement("li",null,"Puts each input number into its buckets"),i.a.createElement("li",null,"Sort each bucket using a simple algorithm, e.g. Insertion Sort and then"),i.a.createElement("li",null,"Concatenates the sorted lists."))),i.a.createElement("li",null,"Bucket Sort considers that the input is an n element array A and that each element A [i] in the array satisfies 0\u2264A [i] ","<"," 1. The code depends upon an auxiliary array B [0....n-1] of linked lists (buckets) and considers that there is a mechanism for maintaining such lists."),i.a.createElement("li",null,i.a.createElement("code",null,"BUCKET-SORT (A)",i.a.createElement("br",null),"1. n \u2190 length [A]",i.a.createElement("br",null),"2. for i \u2190 1 to n",i.a.createElement("br",null),"3. do insert A [i] into list B [n A[i]]",i.a.createElement("br",null),"4. for i \u2190 0 to n-1",i.a.createElement("br",null),"5. do sort list B [i] with insertion sort.",i.a.createElement("br",null),"6. Concatenate the lists B [0], B [1] ...B [n-1] together in order.",i.a.createElement("br",null))),i.a.createElement("li",null,i.a.createElement("img",{src:"https://media.geeksforgeeks.org/wp-content/uploads/BucketSort.png",className:"mx-auto img-fluid"})))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Selection Sort")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Selection Sort works by repeatedly sorting elements. It works as follows: first find the smallest in the array and exchange it with the element in the first position, then find the second smallest element and exchange it with the element in the second position, and continue in this way until the entire array is sorted."),i.a.createElement("li",null,"Selection sort is among the simplest of sorting techniques and it works very well for small files. It has a quite important application as each item is actually moved at the most once."),i.a.createElement("li",null,"Section sort is a method of choice for sorting files with very large objects (records) and small keys. The worst case occurs if the array is already sorted in a descending order and we want to sort them in an ascending order."),i.a.createElement("li",null,"Nonetheless, the time required by selection sort algorithm is not very sensitive to the original order of the array to be sorted: the test if A[j] ","<"," min x is executed exactly the same number of times in every case."),i.a.createElement("li",null,"Selection sort spends most of its time trying to find the minimum element in the unsorted part of the array. It clearly shows the similarity between Selection sort and Bubble sort."),i.a.createElement("li",null,"Bubble sort selects the maximum remaining elements at each stage, but wastes some effort imparting some order to an unsorted part of the array."),i.a.createElement("li",null,"Selection sort is quadratic in both the worst and the average case, and requires no extra memory."),i.a.createElement("li",null,"(n \u2212 1) + (n \u2212 2) + ...+ 2 + 1 = n(n \u2212 1)/2 comparisons."),i.a.createElement("li",null,"These observations hold, no matter what the input data is."),i.a.createElement("li",null,"In the worst case, this could be quadratic, but in the average case, this quantity is O(n log n). It implies that the running time of Selection sort is quite insensitive to the input."),i.a.createElement("li",null,i.a.createElement("img",{src:"https://i.pinimg.com/564x/79/7b/c7/797bc798ab6de4545ae7a013abe28117.jpg",className:"img-fluid",style:{width:"300px",height:"auto"}})),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm: Selection-Sort (A) ",i.a.createElement("br",null),"fori \u2190 1 to n-1 do ",i.a.createElement("br",null),"min j \u2190 i; ",i.a.createElement("br",null),"min x \u2190 A[i] ",i.a.createElement("br",null),"for j \u2190i + 1 to n do ",i.a.createElement("br",null),"if A[j] ","<"," min x then ",i.a.createElement("br",null),"min j \u2190 j ",i.a.createElement("br",null),"min x \u2190 A[j] ",i.a.createElement("br",null),"A[min j] \u2190 A [i] ",i.a.createElement("br",null),"A[i] \u2190 min x ",i.a.createElement("br",null))),i.a.createElement("li",null,i.a.createElement(te.a,null,"Void Selection(int numbers[],int array_size)",i.a.createElement("br",null),"{",i.a.createElement("br",null),"int i, j; ",i.a.createElement("br",null),"int min, temp;  ",i.a.createElement("br",null),"for(i = 0; I ","<","array_size-1; i++)",i.a.createElement("br",null)," ","{",i.a.createElement("br",null),"min = i; ",i.a.createElement("br",null),"for (j = i+1; j ","<"," array_size; j++) ",i.a.createElement("br",null),"if (numbers[j] ","<"," numbers[min]) ",i.a.createElement("br",null),"min = j; ",i.a.createElement("br",null),"temp = numbers[i]; ",i.a.createElement("br",null),"numbers[i] = numbers[min]; ",i.a.createElement("br",null),"numbers[min] = temp; ",i.a.createElement("br",null),"}","}")))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Linear Time Sorting")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,'We have sorting algorithms that can sort "n" numbers in O (n log n) time.'),i.a.createElement("li",null,"Merge Sort and Heap Sort achieve this upper bound in the worst case, and Quick Sort achieves this on Average Case."),i.a.createElement("li",null,'Merge Sort, Quick Sort and Heap Sort algorithm share an interesting property: the sorted order they determined is based only on comparisons between the input elements. We call such a sorting algorithm "Comparison Sort".'),i.a.createElement("li",null,"There is some algorithm that runs faster and takes linear time such as Counting Sort, Radix Sort, and Bucket Sort but they require the special assumption about the input sequence to sort."),i.a.createElement("li",null,"Counting Sort and Radix Sort assumes that the input consists of an integer in a small range. Bucket Sort assumes that a random process that distributes elements uniformly over the interval generates the input."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Shell Sort")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"ShellSort is mainly a variation of Insertion Sort. In insertion sort, we move elements only one position ahead. When an element has to be moved far ahead, many movements are involved. The idea of shellSort is to allow exchange of far items. In shellSort, we make the array h-sorted for a large value of h. We keep reducing the value of h until it becomes 1. An array is said to be h-sorted if all sublists of every h\u2019th element is sorted."),i.a.createElement("li",null,i.a.createElement("strong",null,"algorithm for shell sort."),i.a.createElement("br",null),"Step 1 \u2212 Initialize the value of h",i.a.createElement("br",null),"Step 2 \u2212 Divide the list into smaller sub-list of equal interval h",i.a.createElement("br",null),"Step 3 \u2212 Sort these sub-lists using insertion sort",i.a.createElement("br",null),"Step 3 \u2212 Repeat until complete list is sorted",i.a.createElement("br",null)),i.a.createElement("li",null,i.a.createElement("img",{src:"https://i.stack.imgur.com/WTd9p.jpg",className:"mx-auto img-fluid"}))))))))))},oe=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Heap Sort Algorithms"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Binary Heap")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ol",null,"A Binary Heap is a Binary Tree with following properties.",i.a.createElement("li",null,"It\u2019s a complete tree (All levels are completely filled except possibly the last level and the last level has all keys as left as possible). This property of Binary Heap makes them suitable to be stored in an array."),i.a.createElement("li",null,"A Binary Heap is either Min Heap or Max Heap. In a Min Binary Heap, the key at root must be minimum among all keys present in Binary Heap. The same property must be recursively true for all nodes in Binary Tree. Max Binary Heap is similar to MinHeap."),i.a.createElement("li",null,"How is Binary Heap represented?",i.a.createElement("br",null),"A Binary Heap is a Complete Binary Tree. A binary heap is typically represented as an array.",i.a.createElement("br",null),"The root element will be at Arr[0].",i.a.createElement("br",null),"Below table shows indexes of other nodes for the ith node, i.e., Arr[i]:",i.a.createElement("br",null),"Arr[(i-1)/2] Returns the parent node",i.a.createElement("br",null),"Arr[(2*i)+1] Returns the left child node",i.a.createElement("br",null),"Arr[(2*i)+2] Returns the right child node",i.a.createElement("br",null),"The traversal method use to achieve Array representation is Level Order"),i.a.createElement("li",null,i.a.createElement("strong",null," Analysis:"),i.a.createElement("br",null)," Build max-heap takes O (n) running time. The Heap Sort algorithm makes a call to 'Build Max-Heap' which we take O (n) time & each of the (n-1) calls to Max-heap to fix up a new heap. We know 'Max-Heapify' takes time O (log n)",i.a.createElement("br",null),"The total running time of Heap-Sort is O (n log n)."),i.a.createElement("li",null,"It is an array object can be viewed as Complete Binary Tree. Each node of the Binary Tree corresponds to an element in an array.Length [A],number of elements in array Heap-Size[A], number of elements in a heap stored within array A.",i.a.createElement("br",null),"The root of tree A [1] and gives index 'i' of a node that indices of its parents, left child, and the right child can be computed.",i.a.createElement("br",null),i.a.createElement("code",null,"PARENT (i)  ",i.a.createElement("br",null),"Return floor (i/2)  ",i.a.createElement("br",null),"LEFT (i)  ",i.a.createElement("br",null),"Return 2i  ",i.a.createElement("br",null),"RIGHT (i)  ",i.a.createElement("br",null),"Return 2i+1")),i.a.createElement("li",null,i.a.createElement("img",{src:"https://static.javatpoint.com/tutorial/daa/images/daa-binary-heap.png",className:"img-fluid mx-auto"}))),i.a.createElement("ul",null,i.a.createElement("li",null,"Heap sort is an in-place algorithm. Time Complexity: Time complexity of heapify is O(Logn). Time complexity of createAndBuildHeap() is O(n) and overall time complexity of Heap Sort is O(nLogn)."),i.a.createElement("li",null,"Heap sort algorithm has limited uses because Quicksort and Mergesort are better in practice. Nevertheless, the Heap data structure itself is enormously used."),i.a.createElement("li",null,"Applications of HeapSort 1. Sort a nearly sorted (or K sorted) array 2. k largest(or smallest) elements in an array"),i.a.createElement("li",null,i.a.createElement("strong",null,"  Max-Heap"),i.a.createElement("br",null),"In this heap, the key value of a node is greater than or equal to the key value of the highest child.",i.a.createElement("br",null),i.a.createElement("strong",null," H[Parent(i)] \u2265 H[i]")),i.a.createElement("li",null,i.a.createElement("strong",null,"    Min-Heap"),i.a.createElement("br",null),"In mean-heap, the key value of a node is lesser than or equal to the key value of the lowest child.",i.a.createElement("br",null),i.a.createElement("strong",null,"H[Parent(i)] \u2264 H[i]")))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Array Representation")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"A complete binary tree can be represented by an array, storing its elements using level order traversal.",i.a.createElement("br",null),"Let us consider a heap (as shown below) which will be represented by an array H.",i.a.createElement("br",null),"Considering the starting index as 0, using level order traversal, the elements are being kept in an array"),i.a.createElement("li",{className:"mx-auto"},i.a.createElement("img",{src:"https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/array_representation.jpg",className:"img-fluid mx-auto",style:{width:"300px",height:"300px"}})),i.a.createElement("br",null),i.a.createElement("br",null),i.a.createElement("li",null,"To find the index of the parent of an element at index i, this algorithm Parent (numbers[], i) is used.",i.a.createElement("br",null),i.a.createElement("code",null,"Algorithm: Parent (numbers[], i) ",i.a.createElement("br",null),"if i == 1 ",i.a.createElement("br",null),"return NULL ",i.a.createElement("br",null),"else ",i.a.createElement("br",null),"[i / 2]",i.a.createElement("br",null))),i.a.createElement("li",null,"The index of the left child of an element at index i can be found using the following algorithm, ",i.a.createElement("b",null,i.a.createElement("i",null,"Left-Child (numbers[], i).")),i.a.createElement("br",null),i.a.createElement("code",null,"Algorithm: Left-Child (numbers[], i) ",i.a.createElement("br",null),"If 2 * i \u2264 heapsize ",i.a.createElement("br",null),"return [2 * i] ",i.a.createElement("br",null),"else return NULL")),i.a.createElement("li",null,i.a.createElement("p",null,"The index of the right child of an element at index ",i.a.createElement("b",null,"i")," can be found using the following algorithm, ",i.a.createElement("b",null,i.a.createElement("i",null,"Right-Child(numbers[], i)")),"."),i.a.createElement("code",null,i.a.createElement("b",null,"Algorithm: Right-Child (numbers[], i)")," ",i.a.createElement("br",null),"if 2 * i < heapsize ",i.a.createElement("br",null),"return [2 * i + 1] ",i.a.createElement("br",null),"else ",i.a.createElement("br",null),"return NULL ",i.a.createElement("br",null))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Insert Method")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"To insert an element in a heap, the new element is initially appended to the end of the heap as the last element of the array."),i.a.createElement("li",null,"After inserting this element, heap property may be violated, hence the heap property is repaired by comparing the added element with its parent and moving the added element up a level, swapping positions with the parent. This process is called percolation up."),i.a.createElement("li",null,"The comparison is repeated until the parent is larger than or equal to the percolating element."),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm: Max-Heap-Insert (numbers[], key) ",i.a.createElement("br",null),"heapsize = heapsize + 1 ",i.a.createElement("br",null),"numbers[heapsize] = -\u221e ",i.a.createElement("br",null),"i = heapsize ",i.a.createElement("br",null),"numbers[i] = key ",i.a.createElement("br",null),"while i ",">"," 1 and numbers[Parent(numbers[], i)] ","<"," numbers[i] ",i.a.createElement("br",null),"exchange(numbers[i], numbers[Parent(numbers[], i)]) ",i.a.createElement("br",null),"i = Parent (numbers[], i) ",i.a.createElement("br",null))),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("strong",null," Analysis"),i.a.createElement("br",null),"An element is being added at the end of the array. If it violates the heap property, the element is exchanged with its parent. The height of the tree is log n. Maximum log n number of operations needs to be performed.",i.a.createElement("br",null),"Hence, the complexity of this function is O(log n)."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Heapify Method")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Heapify method rearranges the elements of an array where the left and right sub-tree of ith element obeys the heap property."),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm: Max-Heapify(numbers[], i) ",i.a.createElement("br",null),"leftchild := numbers[2i] ",i.a.createElement("br",null),"rightchild := numbers [2i + 1] ",i.a.createElement("br",null),"if leftchild \u2264 numbers[].size and numbers[leftchild] ",">"," numbers[i] ",i.a.createElement("br",null),"largest := leftchild ",i.a.createElement("br",null),"else ",i.a.createElement("br",null),"largest := i ",i.a.createElement("br",null),"if rightchild \u2264 numbers[].size and numbers[rightchild] ",">"," numbers[largest] ",i.a.createElement("br",null),"largest := rightchild ",i.a.createElement("br",null),"if largest \u2260 i ",i.a.createElement("br",null),"swap numbers[i] with numbers[largest] ",i.a.createElement("br",null),"Max-Heapify(numbers, largest) ",i.a.createElement("br",null))),i.a.createElement("li",null,i.a.createElement("img",{src:"https://www.codesdope.com/staticroot/images/algorithm/heapsort2.gif",className:"mx-auto img-fluid"})),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("strong",null,"Building a Heap:"),i.a.createElement("code",null,"BUILDHEAP (array A, int n)",i.a.createElement("br",null),"1 for i \u2190 n/2 down to 1",i.a.createElement("br",null),"2 do",i.a.createElement("br",null),"3 HEAPIFY (A, i, n)",i.a.createElement("br",null))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Extract Method")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Extract method is used to extract the root element of a Heap. Following is the algorithm."),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm: Heap-Extract-Max (numbers[])  ",i.a.createElement("br",null),"max = numbers[1]  ",i.a.createElement("br",null),"numbers[1] = numbers[heapsize]  ",i.a.createElement("br",null),"heapsize = heapsize \u2013 1  ",i.a.createElement("br",null),"Max-Heapify (numbers[], 1)  ",i.a.createElement("br",null),"return max")),i.a.createElement("li",null,i.a.createElement("strong",null,"HEAP-SORT ALGORITHM:"),i.a.createElement("br",null),i.a.createElement("code",null,"HEAP-SORT (A)",i.a.createElement("br",null),"1. BUILD-MAX-HEAP (A)",i.a.createElement("br",null),"2. For I \u2190 length[A] down to Z",i.a.createElement("br",null),"3. Do exchange A [1] \u2190\u2192 A [i]",i.a.createElement("br",null),"4. Heap-size [A] \u2190 heap-size [A]-1",i.a.createElement("br",null),"5. MAX-HEAPIFY (A,1)"))))))))))},se=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Divide & Conquer Algorithm"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Many algorithms are recursive in nature to solve a given problem recursively dealing with sub-problems.",i.a.createElement("br",null),"In divide and conquer approach, a problem is divided into smaller problems, then the smaller problems are solved independently, and finally the solutions of smaller problems are combined into a solution for the large problem.",i.a.createElement("br",null)),i.a.createElement("li",null,"Generally, divide-and-conquer algorithms have three parts \u2212",i.a.createElement("ul",null,i.a.createElement("li",null,"Divide the problem into a number of sub-problems that are smaller instances of the same problem."),i.a.createElement("li",null,"Conquer the sub-problems by solving them recursively. If they are small enough, solve the sub-problems as base cases."),i.a.createElement("li",null,"Combine the solutions to the sub-problems into the solution for the original problem."))),i.a.createElement("li",null,"There are two fundamental of Divide & Conquer Strategy:",i.a.createElement("br",null),i.a.createElement("ol",null,i.a.createElement("li",null,i.a.createElement("strong",null,i.a.createElement("i",null," Relational Formula:"))," It is the formula that we generate from the given technique. After generation of Formula we apply D&C Strategy, i.e. we break the problem recursively & solve the broken subproblems."),i.a.createElement("li",null,i.a.createElement("strong",null,i.a.createElement("i",null,"Stopping Condition:"))," When we break the problem using Divide & Conquer Strategy, then we need to know that for how much time, we need to apply divide & Conquer. So the condition where the need to stop our recursion steps of D&C is called as Stopping Condition."))),i.a.createElement("li",null,i.a.createElement("img",{src:"https://www.studytonight.com/data-structures/images/divide-conquer.png",className:"img-fluid mx-auto"})),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("strong",null,"Application of Divide and Conquer Approach:"),i.a.createElement("br",null),i.a.createElement("ul",null,i.a.createElement("li",null,"Finding the maximum and minimum of a sequence of numbers"),i.a.createElement("li",null,"Strassen\u2019s matrix multiplication"),i.a.createElement("li",null,"Merge sort"))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h4",{className:"title"},"Linear Search")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"A simple approach is to do linear search, i.e Start from the leftmost element of arr[] and one by one compare x with each element of arr[] If x matches with an element, return the index. If x doesn\u2019t match with any of elements, return -1."),i.a.createElement("li",null,"The time complexity of above algorithm is O(n). Linear search is rarely used practically because other search algorithms such as the binary search algorithm and hash tables allow significantly faster searching comparison to Linear search."),i.a.createElement("li",null,i.a.createElement("code",null,"Input : arr[] = [10, 20, 80, 30, 60, 50, 110, 100, 130, 170]",i.a.createElement("br",null),"x = 110;",i.a.createElement("br",null),"Output : 6",i.a.createElement("br",null),"Element x is present at index 6",i.a.createElement("br",null),"Input : arr[] = [10, 20, 80, 30, 60, 50, 110, 100, 130, 170]",i.a.createElement("br",null),"x = 175;",i.a.createElement("br",null),"Output : -1",i.a.createElement("br",null),"Element x is not present in arr[].",i.a.createElement("br",null))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h4",{className:"title"},"Binary Search")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Binary Search: Search a sorted array by repeatedly dividing the search interval in half.",i.a.createElement("br",null),"Begin with an interval covering the whole array. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise narrow it to the upper half. ",i.a.createElement("br",null),"Repeatedly check until the value is found or the interval is empty.",i.a.createElement("br",null)),i.a.createElement("li",null,"The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(Log n)."),i.a.createElement("li",null,"Linear search runs in O(n) time. Whereas binary search produces the result in O(log n) time",i.a.createElement("br",null),"Let T(n) be the number of comparisons in worst-case in an array of n elements.",i.a.createElement("br",null),"Hence, T(n)= 0 if n=1",i.a.createElement("br",null),"T(n)=T(n2)+1 otherwise",i.a.createElement("br",null),"Using this recurrence relation T(n)=logn.",i.a.createElement("br",null),"Therefore, binary search uses O(logn) time."),i.a.createElement("li",null,i.a.createElement("img",{src:"https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcT0cdaUewc5MinMP7jR9Y2yPdiMtxXq1VNt7A&usqp=CAU",className:"mx-auto img-fluid",height:"300",width:"270"})),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement(te.a,null,"int binarySearch",i.a.createElement("br",null),"(int arr[], int l, int r, int x) ",i.a.createElement("br",null),"{ ",i.a.createElement("br",null),"if (r ",">","= l)  ","{ ",i.a.createElement("br",null),"int mid = l + (r - l) / 2;",i.a.createElement("br",null),"// If the element is present at the middle",i.a.createElement("br",null),"// itself ",i.a.createElement("br",null),"if (arr[mid] == x)",i.a.createElement("br",null),"return mid; ",i.a.createElement("br",null),"// If element is smaller than mid, then ",i.a.createElement("br",null),"// it can only be present in left subarray ",i.a.createElement("br",null),"if (arr[mid] ",">"," x) ",i.a.createElement("br",null),"return binarySearch(arr, l, mid - 1, x);",i.a.createElement("br",null),"// Else the element can only be present ",i.a.createElement("br",null),"// in right subarray ",i.a.createElement("br",null),"return binarySearch(arr, mid + 1, r, x); ",i.a.createElement("br",null),"} ","// We reach here when element is not ",i.a.createElement("br",null),"// present in array ",i.a.createElement("br",null),"return -1; ",i.a.createElement("br",null),"}")))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h4",{className:"title"},"Quick Sort")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"QuickSort is a Divide and Conquer algorithm."),i.a.createElement("li",null,"It picks an element as pivot and partitions the given array around the picked pivot."),i.a.createElement("li",null,"There are many different versions of quickSort that pick pivot in different ways."),i.a.createElement("li",null,"Always pick first element as pivot."),i.a.createElement("li",null,"Always pick last element as pivot (implemented below)"),i.a.createElement("li",null,"Pick a random element as pivot."),i.a.createElement("li",null,"Pick median as pivot."),i.a.createElement("li",null,"The key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time.",i.a.createElement("br",null)),i.a.createElement("li",null,"Quick sort works by partitioning a given array A[p ... r] into two non-empty sub array A[p ... q] and A[q+1 ... r] such that every key in A[p ... q] is less than or equal to every key in A[q+1 ... r]."),i.a.createElement("li",null,"Then, the two sub-arrays are sorted by recursive calls to Quick sort. The exact position of the partition depends on the given array and index q is computed as a part of the partitioning procedure."),i.a.createElement("li",null,i.a.createElement("strong",null,"Analysis"),i.a.createElement("br",null),"The worst case complexity of Quick-Sort algorithm is O(n2). However using this technique, in average cases generally we get the output in O(n log n) time."),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement(te.a,null,"Algorithm: Quick-Sort (A, p, r) ",i.a.createElement("br",null),"if p ","<"," r then ",i.a.createElement("br",null),"q Partition (A, p, r) ",i.a.createElement("br",null),"Quick-Sort (A, p, q) ",i.a.createElement("br",null),"Quick-Sort (A, q + r, r) ",i.a.createElement("br",null))),i.a.createElement("li",null,i.a.createElement("strong",null,"Partitioning the Array : rearranges the sub-arrays in-place"),i.a.createElement(te.a,null,"Function: Partition (A, p, r) ",i.a.createElement("br",null),"x \u2190 A[p] ",i.a.createElement("br",null),"i \u2190 p-1 ",i.a.createElement("br",null),"j \u2190 r+1 ",i.a.createElement("br",null),"while TRUE do ",i.a.createElement("br",null),"Repeat j \u2190 j - 1 ",i.a.createElement("br",null),"until A[j] \u2264 x  ",i.a.createElement("br",null),"Repeat i\u2190 i+1 ",i.a.createElement("br",null),"until A[i] \u2265 x  ",i.a.createElement("br",null),"if i","<"," j then  ",i.a.createElement("br",null),"exchange A[i] \u2194 A[j] ",i.a.createElement("br",null),"else  ",i.a.createElement("br",null),"return j")),i.a.createElement("li",null,i.a.createElement("img",{src:"https://upload.wikimedia.org/wikipedia/commons/9/9c/Quicksort-example.gif",className:"mx-auto img-fluid"})),i.a.createElement("li",null,i.a.createElement("code",null,"arr[] = ",70," ",i.a.createElement("br",null),"Indexes:  0   1   2   3   4   5   6 ",i.a.createElement("br",null),"low = 0, high =  6, pivot = arr[h] = 70",i.a.createElement("br",null),"Initialize index of smaller element, i = -1",i.a.createElement("br",null),"Traverse elements from j = low to high-1",i.a.createElement("br",null),"j = 0 : Since arr[j] ","<","= pivot, do i++ and swap(arr[i], arr[j])",i.a.createElement("br",null),"i = 0 arr[] = ",70," // No change as i and j ",i.a.createElement("br",null),"// are same",i.a.createElement("br",null),"j = 1 : Since arr[j] ",">"," pivot, do nothing",i.a.createElement("br",null),"// No change in i and arr[]",i.a.createElement("br",null),"j = 2 : Since arr[j] ","<","= pivot, do i++ and swap(arr[i], arr[j])",i.a.createElement("br",null),"i = 1",i.a.createElement("br",null),"arr[] = ",70," // We swap 80 and 30 ",i.a.createElement("br",null),"j = 3 : Since arr[j] ",">"," pivot, do nothing",i.a.createElement("br",null),"// No change in i and arr[]",i.a.createElement("br",null),"j = 4 : Since arr[j] ","<","= pivot, do i++ and swap(arr[i], arr[j])",i.a.createElement("br",null),"i = 2",i.a.createElement("br",null),"arr[] = ",70," // 80 and 40 Swapped",i.a.createElement("br",null),"j = 5 : Since arr[j] ","<","= pivot, do i++ and swap arr[i] with arr[j] ",i.a.createElement("br",null),"i = 3 ",i.a.createElement("br",null),"arr[] = ",70," // 90 and 50 Swapped ",i.a.createElement("br",null),"We come out of loop because j is now equal to high-1.",i.a.createElement("br",null),"Finally we place pivot at correct position by swapping",i.a.createElement("br",null),"arr[i+1] and arr[high] (or pivot) ",i.a.createElement("br",null),"arr[] = ",80," // 80 and 70 Swapped ",i.a.createElement("br",null),"Now 70 is at its correct place. All elements smaller than",i.a.createElement("br",null),"70 are before it and all elements greater than 70 are after it. ",i.a.createElement("br",null))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Merge Sort")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Merge Sort works as follows:",i.a.createElement("br",null),i.a.createElement("ol",null,i.a.createElement("li",null,"Divide: Divide the unsorted list into two sublists of about half the size."),i.a.createElement("li",null,"Conquer: Sort each of the two sublists recursively until we have list sizes of length 1, in which case the list items are returned."),i.a.createElement("li",null,"Combine: Join the two sorted Sub lists back into one sorted list.")),"The Main purpose is to sort the unsorted list in nondecreasing order."),i.a.createElement("li",null,"Time Complexity: Sorting arrays on different machines. Merge Sort is a recursive algorithm and time complexity can be expressed as following recurrence relation.",i.a.createElement("br",null),"T(n) = 2T(n/2) + \u03b8(n)"),i.a.createElement("li",null,"The above recurrence can be solved either using Recurrence Tree method or Master method. It falls in case II of Master Method and solution of the recurrence is \u03b8(nLogn). Time complexity of Merge Sort is  \u03b8(nLogn) in all 3 cases (worst, average and best) as merge sort always divides the array into two halves and take linear time to merge two halves."),i.a.createElement("li",null,"Auxiliary Space: O(n)"),i.a.createElement("li",null,"Algorithmic Paradigm: Divide and Conquer"),i.a.createElement("li",null,"Sorting In Place: No in a typical implementation & Stable: Yes"),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("img",{src:"https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRPqEBf9jgK4cVV_T-oWCUGxA4vrddmCky-BA&usqp=CAU",className:"img-fluid mx-auto"})),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm: Merge-Sort (numbers[], p, r) ",i.a.createElement("br",null),"if p ","<"," r then  ",i.a.createElement("br",null),"q = \u230a(p + r) / 2\u230b ",i.a.createElement("br",null),"Merge-Sort (numbers[], p, q) ",i.a.createElement("br",null),"Merge-Sort (numbers[], q + 1, r) ",i.a.createElement("br",null),"Merge (numbers[], p, q, r) ",i.a.createElement("br",null))),i.a.createElement("li",null,i.a.createElement("code",null,"Function: Merge (numbers[], p, q, r)",i.a.createElement("br",null),"n1 = q \u2013 p + 1 ",i.a.createElement("br",null),"n2 = r \u2013 q ",i.a.createElement("br",null),"declare leftnums[1\u2026n1 + 1] and rightnums[1\u2026n2 + 1] temporary arrays ",i.a.createElement("br",null),"for i = 1 to n1 ",i.a.createElement("br",null),"leftnums[i] = numbers[p + i - 1] ",i.a.createElement("br",null),"for j = 1 to n2 ",i.a.createElement("br",null),"rightnums[j] = numbers[q+ j] ",i.a.createElement("br",null),"leftnums[n1 + 1] = \u221e ",i.a.createElement("br",null),"rightnums[n2 + 1] = \u221e ",i.a.createElement("br",null),"i = 1 ",i.a.createElement("br",null),"j = 1 ",i.a.createElement("br",null),"for k = p to r ",i.a.createElement("br",null),"if leftnums[i] \u2264 rightnums[j] ",i.a.createElement("br",null),"numbers[k] = leftnums[i] ",i.a.createElement("br",null),"i = i + 1 ",i.a.createElement("br",null),"else",i.a.createElement("br",null),"numbers[k] = rightnums[j] ",i.a.createElement("br",null),"j = j + 1 ",i.a.createElement("br",null))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Karatsuba algorithm"),i.a.createElement("h6",{className:"title"},"Fast multiplication using Divide and Conquer algorithm")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Two binary strings that represent value of two integers, find the product of two strings. For example, if the first bit string is \u201c1100\u201d and second bit string is \u201c1010\u201d, output should be 120. For simplicity, let the length of two strings be same and be n."),i.a.createElement("li",null,"A Naive Approach is to follow the process we study in school. One by one take all bits of second number and multiply it with all bits of first number. Finally add all multiplications. This algorithm takes O(n^2) time."),i.a.createElement("li",null,"Using Divide and Conquer, we can multiply two integers in less time complexity. We divide the given numbers in two halves. Let the given numbers be X and Y."),i.a.createElement("li",null,i.a.createElement("img",{src:"https://ds055uzetaobb.cloudfront.net/brioche/uploads/wmNBSCMBA1-multiplying.png?width=2400",className:"img-fluid"})),i.a.createElement("li",null,"Time Complexity: Time complexity of the above solution is O(nlog23) = O(n1.59).",i.a.createElement("br",null),"Time complexity of multiplication can be further improved using another Divide and Conquer algorithm, fast Fourier transform. We will soon be discussing fast Fourier transform as a separate post."),i.a.createElement("li",null,i.a.createElement("code",null,"Function karatsuba(X, Y)","{",i.a.createElement("br",null),"// base case",i.a.createElement("br",null),"If (X ","<"," 10 and Y ","<"," 10)",i.a.createElement("br",null),"return X*Y;",i.a.createElement("br",null),"// determine the size of numbers",i.a.createElement("br",null),"size = maximum(Length(string(X)), Length(string(Y)))",i.a.createElement("br",null),"// Split X and Y",i.a.createElement("br",null),"n = ceil(size/2)",i.a.createElement("br",null),"p = power(10,n) // equivalent to 10n",i.a.createElement("br",null),"a = floor(X/p)",i.a.createElement("br",null),"b = X%p",i.a.createElement("br",null),"c = floor(Y/p)",i.a.createElement("br",null),"d = Y%p",i.a.createElement("br",null),"// Recur until base case",i.a.createElement("br",null),"ac = karatsuba(a,c)",i.a.createElement("br",null),"bd = karatsuba(b,d)",i.a.createElement("br",null),"e = karatsuba(a+c, b+d) - ac - bd",i.a.createElement("br",null),"// Return the Multiplication",i.a.createElement("br",null),"return power(10,2*n)*ac + power(10,n)*e + b",i.a.createElement("br",null),"}")))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Strassen\u2019s Matrix Multiplication")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Normal Matrix Algorithms take O(n^3) time to execute.. In this context, using Strassen\u2019s Matrix multiplication algorithm, the time consumption can be improved a little bit."),i.a.createElement("li",null,"Strassen\u2019s Matrix multiplication can be performed only on square matrices where n is a power of 2. Order of both of the matrices are n \xd7 n."),i.a.createElement("li",null,"Divide X, Y and Z into four (n/2)\xd7(n/2) matrices"),i.a.createElement("li",null,"1) Divide matrices A and B in 4 sub-matrices of size N/2 x N/2 as shown in the below diagram.",i.a.createElement("br",null),"2) Calculate following values recursively. ae + bg, af + bh, ce + dg and cf + dh."),i.a.createElement("li",null,"Time Complexity of Strassen\u2019s Method:",i.a.createElement("br",null),"Addition and Subtraction of two matrices takes O(N2) time. So time complexity can be written as T(N) = 7T(N/2) +  O(N2)",i.a.createElement("br",null),"From Master's Theorem, time complexity of above method is",i.a.createElement("strong",null,i.a.createElement("i",null,"O(NLog7) which is approximately O(N2.8074)"))),i.a.createElement("li",null,"Generally Strassen\u2019s Method is not preferred for practical applications for following reasons.",i.a.createElement("br",null),"1) The constants used in Strassen\u2019s method are high and for a typical application Naive method works better."),i.a.createElement("li",null,"2) For Sparse matrices, there are better methods especially designed for them."),i.a.createElement("li",null,"3) The submatrices in recursion take extra space."),i.a.createElement("li",null,"4) Because of the limited precision of computer arithmetic on noninteger values,"),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("img",{src:"data:image/png;base64,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",className:"mx-auto img-fluid"})))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Exponentials using Divide & Conquer Approach")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("strong",null," Linear Approach:"),i.a.createElement("br",null),"The function given in question will take O(n), because the product will happen n times."),i.a.createElement("li",null,"The result is derived in a linear fashion multiplying a, n times. So Product is computed as",i.a.createElement("strong",null,i.a.createElement("i",null,"  Prod = a * a * a * \u2026 \u2026 n-times"))),i.a.createElement("li",null,i.a.createElement("code",null,"long power(int a, int n)","{","if(n==0) return 1; else return a * power(a, n-1)","}")),i.a.createElement("li",null,i.a.createElement("strong",null,"Divide & Conquer Approach:"),i.a.createElement("br",null),"If we use the divide & conquer approach the time complexity can be reduced to O(lg(n)). This way we can get the same difference which is there in the linear search and binary search."),i.a.createElement("li",null,"The Divide & Conquer approach square a each time, rather than multiplying it with a itself. i.e If we want to compute 2^8 we actually compute it like ",i.a.createElement("code",null,"  Prod = ( (a ^ 2) ^ 2) ^ 2"),i.a.createElement("br",null),"Hence the operation (of square) will be performed only 3 (lg(8)) times and not 8 times."),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement(te.a,null,"long power(int a, int n)",i.a.createElement("br",null),"{",i.a.createElement("br",null),"if(n==0)",i.a.createElement("br",null),"return 0;",i.a.createElement("br",null),"if(a == 0)",i.a.createElement("br",null),"return 0;",i.a.createElement("br",null),"if(n%2 == 0) /* b is even */",i.a.createElement("br",null),"return power(a*a, b/2);",i.a.createElement("br",null),"else",i.a.createElement("br",null),"return a * power(a*a, b/2);",i.a.createElement("br",null),"}"))))))))))},ce=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Max-Min Problem"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"})),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"The Max-Min Problem in algorithm analysis is finding the maximum and minimum value in an array."),i.a.createElement("li",null,"To find the maximum and minimum numbers in a given array numbers[] of size n, the following algorithm can be used. First we are representing the naive method and then we will present divide and conquer approach.",i.a.createElement("br",null),"The number of comparison in Naive method is ",i.a.createElement("strong",null,i.a.createElement("i",null," 2n - 2")),"."),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("strong",null,"solving using Divide and Conquer Approach:",i.a.createElement("br",null)),"In this approach, the array is divided into two halves. Then using recursive approach maximum and minimum numbers in each halves are found. Later, return the maximum of two maxima of each half and the minimum of two minima of each half."),i.a.createElement("li",null,"In this given problem, the number of elements in an array is y\u2212x+1, where y is greater than or equal to x."),i.a.createElement("li",null,"Max\u2212Min(x,y) will return the maximum and minimum values of an array numbers[x...y]."),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm: Max - Min(x, y) ",i.a.createElement("br",null),"if y \u2013 x \u2264 1 then  ",i.a.createElement("br",null),"return (max(numbers[x], numbers[y]), min((numbers[x], numbers[y])) ",i.a.createElement("br",null),"else ",i.a.createElement("br",null),"(max1, min1):= maxmin(x, \u230a((x + y)/2)\u230b) ",i.a.createElement("br",null),"(max2, min2):= maxmin(\u230a((x + y)/2) + 1)\u230b,y) ",i.a.createElement("br",null),"return (max(max1, max2), min(min1, min2)) ",i.a.createElement("br",null))),i.a.createElement("li",null,i.a.createElement("strong",null,"Analysis")," ",i.a.createElement("br",null),"Let T(n) be the number of comparisons made by Max\u2212Min(x,y), where the number of elements n=y\u2212x+1."),i.a.createElement("li",null,"If T(n) represents the numbers, then the recurrence relation can be represented a",i.a.createElement("br",null),"T(n)=T(\u230an/2\u230b)+T(\u2308n/2\u2309)+2 for n",">","2 ",i.a.createElement("br",null),"T(n)=1 for n=2 ",i.a.createElement("br",null),"T(n)=0 for n=1"),i.a.createElement("li",null,"n is in the form of power of 2. Hence, n = 2k where k is height of the recursion tree.",i.a.createElement("br",null),"T(n)=2.T(n/2)+2=2.(2.T(n/4)+2)+2.....=3n/2\u22122"),i.a.createElement("li",null,"Asymptotic notation is represented by O(n)")))))))))},me=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Dynamic Programming"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Dynamic Programming is the most powerful design technique for solving optimization problems."),i.a.createElement("li",null,"Divide & Conquer algorithm partition the problem into disjoint subproblems solve the subproblems recursively and then combine their solution to solve the original problems."),i.a.createElement("li",null,"Dynamic Programming is used when the subproblems are not independent, e.g. when they share the same subproblems. In this case, divide and conquer may do more work than necessary, because it solves the same sub problem multiple times."),i.a.createElement("li",null,"Dynamic Programming solves each subproblems just once and stores the result in a table so that it can be repeatedly retrieved if needed again."),i.a.createElement("li",null,"Dynamic Programming is a Bottom-up approach- we solve all possible small problems and then combine to obtain solutions for bigger problems."),i.a.createElement("li",null,'Dynamic Programming is a paradigm of algorithm design in which an optimization problem is solved by a combination of achieving sub-problem solutions and appearing to the "principle of optimality".'))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Elements of Dynamic Programming")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("strong",null," three elements that characterize a dynamic programming algorithm:-"),i.a.createElement("br",null),i.a.createElement("ol",null,i.a.createElement("li",null,i.a.createElement("img",{src:"https://static.javatpoint.com/tutorial/daa/images/elements-of-dynamic-programming.png",className:"mx-auto img-fluid m=3",style:{width:"300px",height:"300px",margin:"5px"}})),i.a.createElement("li",null,"Substructure: Decompose the given problem into smaller subproblems. Express the solution of the original problem in terms of the solution for smaller problems."),i.a.createElement("li",null,"Table Structure: After solving the sub-problems, store the results to the sub problems in a table. This is done because subproblem solutions are reused many times, and we do not want to repeatedly solve the same problem over and over again."),i.a.createElement("li",null,"Bottom-up Computation: Using table, combine the solution of smaller subproblems to solve larger subproblems and eventually arrives at a solution to complete problem.")))),i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("strong",null,"Characteristics of Dynamic Programming:"),i.a.createElement("br",null)),i.a.createElement("li",null,"Optimal Substructure: If an optimal solution contains optimal sub solutions then a problem exhibits optimal substructure."),i.a.createElement("li",null,"Overlapping subproblems: When a recursive algorithm would visit the same subproblems repeatedly, then a problem has overlapping subproblems."),i.a.createElement("li",null,"If a problem has optimal substructure, then we can recursively define an optimal solution. If a problem has overlapping subproblems, then we can improve on a recursive implementation by computing each subproblem only once."),i.a.createElement("li",null,"If a problem doesn't have optimal substructure, there is no basis for defining a recursive algorithm to find the optimal solutions. If a problem doesn't have overlapping sub problems, we don't have anything to gain by using dynamic programming."),"If the space of subproblems is enough (i.e. polynomial in the size of the input), dynamic programming can be much more efficient than recursion."),i.a.createElement("ol",null,i.a.createElement("li",null,"Stages: The problem can be divided into several subproblems, which are called stages. A stage is a small portion of a given problem. For example, in the shortest path problem, they were defined by the structure of the graph."),i.a.createElement("li",null,"States: Each stage has several states associated with it. The states for the shortest path problem was the node reached."),i.a.createElement("li",null,"Decision: At each stage, there can be multiple choices out of which one of the best decisions should be taken. The decision taken at every stage should be optimal; this is called a stage decision."),i.a.createElement("li",null,"Optimal policy: It is a rule which determines the decision at each stage; a policy is called an optimal policy if it is globally optimal. This is known as Bellman principle of optimality."),i.a.createElement("li",null,"Given the current state, the optimal choices for each of the remaining states does not depend on the previous states or decisions. In the shortest path problem, it was not necessary to know how we got a node only that we did. There exist a recursive relationship that identify the optimal decisions for stage j, given that stage j+1, has already been solved. The final stage must be solved by itself.")),i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("h6",null,"  Development of Dynamic Programming Algorithm: 4 Steps"),"Characterize the structure of an optimal solution."),i.a.createElement("li",null,"Recursively defined the value of the optimal solution. Like Divide and Conquer, divide the problem into two or more optimal parts recursively. This helps to determine what the solution will look like."),i.a.createElement("li",null,"Compute the value of the optimal solution from the bottom up (starting with the smallest subproblems)"),i.a.createElement("li",null,"Construct the optimal solution for the entire problem form the computed values of smaller subproblems."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Application")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ol",null,i.a.createElement("li",null,"0/1 knapsack problem"),i.a.createElement("li",null,"Mathematical optimization problem"),i.a.createElement("li",null,"All pair Shortest path problem"),i.a.createElement("li",null,"Reliability design problem"),i.a.createElement("li",null,"Longest common subsequence (LCS)"),i.a.createElement("li",null,"Flight control and robotics control"),i.a.createElement("li",null,"Time-sharing: It schedules the job to maximize CPU usage"))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Principle of Optimality")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Definition: A problem is said to satisfy the Principle of Optimality if the subsolutions of an optimal solution of the problem are themesleves optimal solutions for their subproblems."),i.a.createElement("li",null,"Examples:",i.a.createElement("br",null),"The shortest path problem satisfies the Principle of Optimality."),i.a.createElement("li",null,"This is because if a,x1,x2,...,xn,b is a shortest path from node a to node b in a graph, then the portion of xi to xj on that path is a shortest path from xi to xj."),i.a.createElement("li",null,"The longest path problem, on the other hand, does not satisfy the Principle of Optimality. Take for example the undirected graph G of nodes a, b, c, d, and e, and edges (a,b) (b,c) (c,d) (d,e) and (e,a). That is, G is a ring. The longest (noncyclic) path from a to d to a,b,c,d. The sub-path from b to c on that path is simply the edge b,c. But that is not the longest path from b to c. Rather, b,a,e,d,c is the longest path. Thus, the subpath on a longest path is not necessarily a longest path."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Binomial Coefficient")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"A binomial coefficient C(n, k) can be defined as the coefficient of X^k in the expansion of (1 + X)^n."),i.a.createElement("li",null,"A binomial coefficient C(n, k) also gives the number of ways, disregarding order, that k objects can be chosen from among n objects; more formally, the number of k-element subsets (or k-combinations) of an n-element set."),i.a.createElement("li",null,i.a.createElement("ol",null,i.a.createElement("li",null,i.a.createElement("strong",null," Optimal Substructure :"),"The value of C(n, k) can be recursively calculated using following standard formula for Binomial Coefficients.",i.a.createElement("br",null),i.a.createElement("code",null,"   C(n, k) = C(n-1, k-1) + C(n-1, k)",i.a.createElement("br",null),"C(n, 0) = C(n, n) = 1")),i.a.createElement("li",null,i.a.createElement("strong",null,"Overlapping Subproblems : ")," ",i.a.createElement("br",null),"It should be noted that the above function computes the same subproblems again and again."),i.a.createElement("li",null,"Time Complexity: O(n*k)",i.a.createElement("br",null),"Auxiliary Space: O(n*k)"))),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement(te.a,null,"Let's say we want to calculate C(4, 3), ",i.a.createElement("br",null),"i.e. n=4, k=3:",i.a.createElement("br",null),"All elements of array C of size 4 (k+1)",i.a.createElement("br",null),"are initialized to ZERO.",i.a.createElement("br",null),"i.e.C[0]=C[1]=C[2]=C[3]=C[4]=0;",i.a.createElement("br",null),"Then C[0] is set to 1",i.a.createElement("br",null),"For i = 1:",i.a.createElement("br",null),"C[1]=C[1] + C[0]=0 + 1=1=",">"," C(1,1)=1",i.a.createElement("br",null),"For i=2:",i.a.createElement("br",null),"C[2]=C[2] + C[1]=0 + 1=1=",">"," C(2,2)=1",i.a.createElement("br",null),"C[1]=C[1] + C[0]=1 + 1=2=",">"," C(2,2)=2",i.a.createElement("br",null),"For i=3:",i.a.createElement("br",null),"C[3]=C[3] + C[2]=0 + 1=1=",">"," C(3,3)=1",i.a.createElement("br",null),"C[2]=C[2] + C[1]=1 + 2=3=",">"," C(3,2)=3",i.a.createElement("br",null),"C[1]=C[1] + C[0]=2 + 1=3=",">"," C(3,1)=3",i.a.createElement("br",null),"For i=4:",i.a.createElement("br",null),"C[4]=C[4] + C[3]=0 + 1=1=",">"," C(4,4)=1",i.a.createElement("br",null),"C[3]=C[3] + C[2]=1 + 3=4=",">"," C(4,3)=4",i.a.createElement("br",null),"C[2]=C[2] + C[1]=3 + 3=6=",">"," C(4,2)=6",i.a.createElement("br",null),"C[1]=C[1] + C[0]=3 + 1=4=",">"," C(4,1)=4",i.a.createElement("br",null),"C(4,3)= 4 is would be",i.a.createElement("br",null),"the answer in our example.")))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Assembly Line Scheduling ")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"A car factory has two assembly lines, each with n stations. A station is denoted by Si,j where i is either 1 or 2 and indicates the assembly line the station is on, and j indicates the number of the station. ",i.a.createElement("br",null)),i.a.createElement("li",null,"The time taken per station is denoted by ai,j. Each station is dedicated to some sort of work like engine fitting, body fitting, painting, and so on. So, a car chassis must pass through each of the n stations in order before exiting the factory."),i.a.createElement("li",null,"The parallel stations of the two assembly lines perform the same task. After it passes through station Si,j, it will continue to station Si,j+1 unless it decides to transfer to the other line. ",i.a.createElement("br",null)),i.a.createElement("li",null,"Continuing on the same line incurs no extra cost, but transferring from line i at station j \u2013 1 to station j on the other line takes time ti,j. Each assembly line takes an entry time ei and exit time xi which may be different for the two lines. Give an algorithm for computing the minimum time it will take to build a car chassis."),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("img",{src:"data:image/jpeg;base64,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  iDnWdJT2lDaCCT7RFaRsfc         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",className:"fluid-img mx-auto"}))),i.a.createElement("ul",null,i.a.createElement("li",null,"The following information can be extracted from the problem statement to make it simpler:\xa0"),i.a.createElement("li",null,"Two assembly lines, 1 and 2, each with stations from 1 to n."),i.a.createElement("li",null,"A car chassis must pass through all stations from 1 to n in order(in any of the two assembly lines). i.e. it cannot jump from station i to station j if they are not at one move distance."),i.a.createElement("li",null,"The car chassis can move one station forward in the same line, or one station diagonally in the other line. It incurs an extra cost ti, j to move to station j from line i. No cost is incurred for movement in same line."),i.a.createElement("li",null,"The time taken in station j on line i is a",i.a.createElement("sub",null,"i, j"),"."),i.a.createElement("li",null,"S",i.a.createElement("sub",null,"i, j")," represents a station j on line i.")),i.a.createElement("ul",null,i.a.createElement("strong",null),i.a.createElement("li",null,"We can easily find the ith factorial if (i-1)th factorial is known. Can we apply the similar funda here?"),i.a.createElement("li",null,"If the minimum time taken by the chassis to leave station Si, j-1 is known, the minimum time taken to leave station Si, j can be calculated quickly by combining ai, j and ti, j."),i.a.createElement("li",null,"T1(j) indicates the minimum time taken by the car chassis to leave station j on assembly line 1."),i.a.createElement("li",null,"T2(j) indicates the minimum time taken by the car chassis to leave station j on assembly line 2."),i.a.createElement("li",null,i.a.createElement("strong",null,"Base cases:"),i.a.createElement("br",null),"The entry time ei comes into picture only when the car chassis enters the car factory. Time taken to leave the first station in line 1 is given by:"),i.a.createElement("li",null,"T1(1) = Entry time in Line 1 + Time spent in station S1,1 ",i.a.createElement("br",null),"T1(1) = e1 + a1,1"),i.a.createElement("li",null,"Similarly, time taken to leave the first station in line 2 is given by: ",i.a.createElement("br",null),"T2(1) = e2 + a2,1"),i.a.createElement("li",null,"The time complexity of the above dynamic programming implementation of the assembly line scheduling problem is O(n)."),i.a.createElement("li",null,i.a.createElement("strong",null," Recursive Solution:"),i.a.createElement("br",null),"The chassis at station S[1,j] can come either from station S[1,j\u22121] or station S[2,j\u22121] (Since, the tasks done by S[1,j] and S[2,j] are same). But if the chassis comes from S[2,j\u22121], it additionally incurs the transfer cost to change the assembly line ( like t[2,j-1] ). Thus, the recursion to reach the station j in assembly line i are as follows:"),i.a.createElement("li",null,i.a.createElement("img",{src:"https://miro.medium.com/max/1002/1*Bn7g0Du3IABMzd_qz13G-A.png",className:"mx-auto img-fluid"})),i.a.createElement("li",null,"If as discussed above we consider 2 assembly line. Then f1[1] and f2[1] is defined as algorithm by adding starting cost and first station cost.",i.a.createElement("br",null),"Then applies our recursive solution for n station points.here l1[j] denotes from which assembly line chassis has come."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Fibonacci Sequence")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Fibonacci sequence is the sequence of numbers in which every next item is the total of the previous two items. And each number of the Fibonacci sequence is called Fibonacci number.",i.a.createElement("br",null),"Example: 0 ,1,1,2,3,5,8,13,21,....................... is a Fibonacci sequence."),i.a.createElement("li",null,i.a.createElement("div",null,i.a.createElement("pre",null,"F",i.a.createElement("sub",null,"0")," = 0",i.a.createElement("br",null),"F",i.a.createElement("sub",null,"n"),"=1",i.a.createElement("br",null),"F",i.a.createElement("sub",null,"n"),"=F",i.a.createElement("sub",null,"(n-1)"),"+ F",i.a.createElement("sub",null,"(n-2)"),i.a.createElement("br",null))),i.a.createElement("br",null),i.a.createElement("img",{src:"https://static.javatpoint.com/tutorial/daa/images/fibonacci-sequence.png",className:"img-fluid mx-auto mb-2"}),i.a.createElement("pre",null,i.a.createElement("strong",null,"FIB (n) "),i.a.createElement("br",null),"1. If (n < 2) ",i.a.createElement("br",null),"2. then return n ",i.a.createElement("br",null),"3. else return FIB (n - 1) + FIB (n - 2)")),i.a.createElement("li",null,i.a.createElement("p",null,"This algorithm clearly takes only O (n) time to compute Fn. By contrast, the original recursive algorithm takes",i.a.createElement("br",null)," O (\u2205",i.a.createElement("sup",null,"n;"),"),\u2205 = ",i.a.createElement("img",{src:"https://static.javatpoint.com/tutorial/daa/images/fibonacci-sequence2.png",style:{margin:"5px 4px -15px 0"},alt:"Fibonacci sequence"}),"= 1.618. ITERFIB conclude an exponential speedup over the original recursive algorithm.")))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Flyod warshall Algorithm")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"The all pair shortest path algorithm is also known as Floyd-Warshall algorithm is used to find all pair shortest path problem from a given weighted graph. As a result of this algorithm, it will generate a matrix, which will represent the minimum distance from any node to all other nodes in the graph."),i.a.createElement("li",null,"At first the output matrix is same as given cost matrix of the graph. After that the output matrix will be updated with all vertices k as the intermediate vertex."),i.a.createElement("li",null,"The time complexity of this algorithm is O(V3), here V is the number of vertices in the graph."),i.a.createElement("li",null,"Time Complexity: O(V^3)"),i.a.createElement("li",null,i.a.createElement("p",null,i.a.createElement("strong",null,"Example:")),i.a.createElement("pre",null,i.a.createElement("strong",null,"Input:"),"graph[][] = ","{"," ","{","0,   5,  INF, 10","}",",",i.a.createElement("br",null),"{","INF,  0,  3,  INF ","}",",",i.a.createElement("br",null),"{","INF, INF, 0,   1","}",",",i.a.createElement("br",null),"{","INF, INF, INF, 0","}","}",i.a.createElement("br",null),"which represents the following graph",i.a.createElement("br",null),"10  ",i.a.createElement("br",null),"(0)-------\x3e(3)",i.a.createElement("br",null),"|         /|\\",i.a.createElement("br",null),"5 |          |",i.a.createElement("br",null),"|          | 1",i.a.createElement("br",null),"\\|/         |",i.a.createElement("br",null),"(1)-------\x3e(2)",i.a.createElement("br",null),"3       ",i.a.createElement("br",null),"Note that the value of graph[i][j] is 0",i.a.createElement("br",null)," if i is equal to j ",i.a.createElement("br",null),"And graph[i][j] is INF (infinite) ",i.a.createElement("br",null),"if there is no edge from vertex i to j.",i.a.createElement("br",null),i.a.createElement("strong",null,"Output:"),i.a.createElement("br",null),"Shortest distance matrix",i.a.createElement("br",null),"0      5      8      9",i.a.createElement("br",null),"INF      0      3      4",i.a.createElement("br",null),"INF    INF      0      1",i.a.createElement("br",null),"INF    INF    INF      0")),i.a.createElement("li",null,i.a.createElement("code",null,i.a.createElement("strong",null,"floydWarshal(cost)"),i.a.createElement("br",null),"Input \u2212 The cost matrix of given Graph.",i.a.createElement("br",null),"Output \u2212 Matrix to for shortest path between any vertex to any vertex.",i.a.createElement("br",null),"Begin",i.a.createElement("br",null),"for k := 0 to n, do",i.a.createElement("br",null),"for i := 0 to n, do",i.a.createElement("br",null),"for j := 0 to n, do",i.a.createElement("br",null),"if cost[i,k] + cost[k,j] ","<"," cost[i,j], then",i.a.createElement("br",null),"cost[i,j] := cost[i,k] + cost[k,j]",i.a.createElement("br",null),"done",i.a.createElement("br",null),"done",i.a.createElement("br",null),"done",i.a.createElement("br",null),"display the current cost matrix",i.a.createElement("br",null),"End"))))))))))},ue=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Knapsack Problem"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Knapsack is basically means bag. A bag of given capacity.",i.a.createElement("br",null),"We want to pack n items in your luggage."),i.a.createElement("li",null,"The ith item is worth vi dollars and weight wi pounds.",i.a.createElement("br",null),"Take as valuable a load as possible, but cannot exceed W pounds.",i.a.createElement("br",null),"vi wi W are integers."),i.a.createElement("li",null,i.a.createElement("strong",null,"W \u2264 capacity  ",i.a.createElement("br",null),"Value \u2190 Max")),i.a.createElement("li",null,"Time Complexity: O(2^n).",i.a.createElement("br",null),"As there are redundant subproblems.",i.a.createElement("br",null),"Auxiliary Space :O(1).",i.a.createElement("br",null),"As no extra data structure has been used for storing values."),i.a.createElement("li",null,i.a.createElement("strong",null,"Input:")," ",i.a.createElement("br",null),"Knapsack of capacity",i.a.createElement("br",null),"List (Array) of weight and their corresponding value."),i.a.createElement("li",null,i.a.createElement("strong",null,"  Output: "),"To maximize profit and minimize weight in capacity.",i.a.createElement("br",null),"The knapsack problem where we have to pack the knapsack with maximum value in such a manner that the total weight of the items should not be greater than the capacity of the knapsack."),i.a.createElement("li",null,"Knapsack problem can be further divided into two parts: ",i.a.createElement("br",null),"1. Fractional Knapsack: Fractional knapsack problem can be solved by Greedy Strategy where as 0 /1 problem is not")),i.a.createElement("ul",null,i.a.createElement("li",null,"0/1 Knapsack Problem:",i.a.createElement("br",null),"In this item cannot be broken which means thief should take the item as a whole or should leave it. That's why it is called 0/1 knapsack Problem."),i.a.createElement("li",null,"Each item is taken or not taken.",i.a.createElement("br",null),"Cannot take a fractional amount of an item taken or take an item more than once.",i.a.createElement("br",null),"It cannot be solved by the Greedy Approach because it is enable to fill the knapsack to capacity.",i.a.createElement("br",null),"Greedy Approach doesn't ensure an Optimal Solution.",i.a.createElement("br",null))),i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("code",null,"KNAPSACK (n, W)",i.a.createElement("br",null),"for w = 0, W",i.a.createElement("br",null),"do V [0,w] \u2190 0",i.a.createElement("br",null),"for i=0, n",i.a.createElement("br",null),"do V [i, 0] \u2190 0",i.a.createElement("br",null),"for w = 0, W",i.a.createElement("br",null),"do if (wi\u2264 w & vi + V [i-1, w -  wi]",">"," V [i -1,W])",i.a.createElement("br",null),"then V [i, W] \u2190 vi + V [i - 1, w - wi]",i.a.createElement("br",null),"else V [i, W] \u2190 V [i - 1, w]",i.a.createElement("br",null))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"0-1 Knapsack Problem")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"In this item cannot be broken which means thief should take the item as a whole or should leave it. That's why it is called 0/1 knapsack Problem."),i.a.createElement("li",null,"Each item is taken or not taken."),i.a.createElement("li",null,"Cannot take a fractional amount of an item taken or take an item more than once."),i.a.createElement("li",null,"It cannot be solved by the Greedy Approach because it is enable to fill the knapsack to capacity. in case of 0-1 Knapsack, the value of xi can be either 0 or 1, where other constraints remain the same."),i.a.createElement("li",null,"Greedy Approach doesn't ensure an Optimal Solution. In many instances, Greedy approach may give an optimal solution."),i.a.createElement("li",null,"Items  |A    B   C   D ",i.a.createElement("br",null),"Profit |24   18  18  10",i.a.createElement("br",null),"Weight |24   10  10   7",i.a.createElement("br",null)),i.a.createElement("strong",null,i.a.createElement("li",null,"capacity of the knapsack is W = 25")),i.a.createElement("li",null,"Without considering the profit per unit weight (pi/wi), if we apply Greedy approach to solve this problem, first item A will be selected as it will contribute maximum profit among all the elements."),i.a.createElement("li",null,"After selecting item A, no more item will be selected. Hence, for this given set of items total profit is 24. Whereas, the optimal solution can be achieved by selecting items, B and C, where the total profit is 18 + 18 = 36."),i.a.createElement("li",null,i.a.createElement("strong",null,"Dynamic-Programming Approach")),i.a.createElement("li",null,"Let i be the highest-numbered item in an optimal solution S for W dollars. Then S' = S - [i] is an optimal solution for W - wi dollars and the value to the solution S is Vi plus the value of the sub-problem."),i.a.createElement("li",null,"We can express this fact in the following formula: define c[i, w] to be the solution for items 1,2, \u2026 , i and the maximum weight w."),i.a.createElement("li",null,i.a.createElement("ul",null,"Inputs",i.a.createElement("li",null,"The maximum weight W"),i.a.createElement("li",null,"The number of items n"),i.a.createElement("li",null,"The two sequences v = ","<","v1, v2, \u2026, vn",">"," and w = ","<","w1, w2, \u2026, wn",">"))),i.a.createElement("li",null,"The set of items to take can be deduced from the table, starting at c[n, w] and tracing backwards where the optimal values came from.",i.a.createElement("br",null),"If c[i, w] = c[i-1, w], then item i is not part of the solution, and we continue tracing with c[i-1, w]. Otherwise, item i is part of the solution, and we continue tracing with c[i-1, w-W].",i.a.createElement("br",null)),i.a.createElement("li",null,i.a.createElement("code",null,"Dynamic-0-1-knapsack (v, w, n, W) ",i.a.createElement("br",null),"for w = 0 to W do ",i.a.createElement("br",null),"c[0, w] = 0 ",i.a.createElement("br",null),"for i = 1 to n do ",i.a.createElement("br",null),"c[i, 0] = 0 ",i.a.createElement("br",null),"for w = 1 to W do ",i.a.createElement("br",null),"if wi \u2264 w then ",i.a.createElement("br",null),"if vi + c[i-1, w-wi] then ",i.a.createElement("br",null),"c[i, w] = vi + c[i-1, w-wi] ",i.a.createElement("br",null),"else c[i, w] = c[i-1, w] ",i.a.createElement("br",null),"else ",i.a.createElement("br",null),"c[i, w] = c[i-1, w] ",i.a.createElement("br",null))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Fractional Knapsack")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"In this case, items can be broken into smaller pieces, hence the thief can select fractions of items."),i.a.createElement("li",null,i.a.createElement("p",null,"There are ",i.a.createElement("b",null,"n")," items in the store")),i.a.createElement("li",null,i.a.createElement("p",null,"Weight of ",i.a.createElement("b",null,"i",i.a.createElement("sup",null,"th"))," item w",i.a.createElement("sub",null,"i")," ",">"," 0")),i.a.createElement("li",null,i.a.createElement("p",null,"Profit for ",i.a.createElement("b",null,"i",i.a.createElement("sup",null,"th"))," item p",i.a.createElement("sub",null,"i")," ",">"," 0 and")),i.a.createElement("li",null,i.a.createElement("p",null,"Capacity of the Knapsack is ",i.a.createElement("b",null,"W"))),i.a.createElement("li",null,"In this version of Knapsack problem, items can be broken into smaller pieces. So, the thief may take only a fraction xi of ith item.",i.a.createElement("br",null),i.a.createElement("strong",null,"0\u2a7dxi\u2a7d1"),i.a.createElement("br",null),"The ith item contributes the weight xi.wi to the total weight in the knapsack and profit xi.pi to the total profit."),i.a.createElement("li",null,"objective of this algorithm is to",i.a.createElement("br",null),"maximize\u2211n=1n(xi.pi)",i.a.createElement("br",null),"subject to constraint,",i.a.createElement("br",null),"\u2211n=1n(xi.wi)\u2a7dW"),i.a.createElement("li",null,"It is clear that an optimal solution must fill the knapsack exactly, otherwise we could add a fraction of one of the remaining items and increase the overall profit.",i.a.createElement("br",null),"Thus, an optimal solution can be obtained by",i.a.createElement("br",null),"\u2211n=1n(xi.wi)=W In this context, first we need to sort those items according to the value of piwi, so that pi+1wi+1 \u2264 piwi . Here, x is an array to store the fraction of items."),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm: Greedy-Fractional-Knapsack (w[1..n], p[1..n], W) ",i.a.createElement("br",null),"for i = 1 to n ",i.a.createElement("br",null),"do x[i] = 0 ",i.a.createElement("br",null),"weight = 0 ",i.a.createElement("br",null),"for i = 1 to n ",i.a.createElement("br",null),"if weight + w[i] \u2264 W then  ",i.a.createElement("br",null),"x[i] = 1 ",i.a.createElement("br",null),"weight = weight + w[i] ",i.a.createElement("br",null),"else ",i.a.createElement("br",null),"x[i] = (W - weight) / w[i] ",i.a.createElement("br",null),"weight = W ",i.a.createElement("br",null),"break ",i.a.createElement("br",null),"return x")),i.a.createElement("li",null,"If the provided items are already sorted into a decreasing order of piwi, then the whileloop takes a time in O(n); Therefore, the total time including the sort is in O(n logn).")))))))))},he=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Matrix Chain Multiplication"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"If a chain of matrices is given, we have to find the minimum number of the correct sequence of matrices to multiply."),i.a.createElement("li",null,"Given a sequence of matrices, find the most efficient way to multiply these matrices together. The problem is not actually to perform the multiplications, but merely to decide in which order to perform the multiplications. We have many options to multiply a chain of matrices because matrix multiplication is associative. In other words, no matter how we parenthesize the product, the result will be the same. For example, if we had four matrices A, B, C, and D, we would have:"),i.a.createElement("li",null,"Time Complexity: O(n3 )",i.a.createElement("br",null),"Auxiliary Space: O(n2)"),i.a.createElement("li",null,"If A = \u230aaij\u230b is a p x q matrix ",i.a.createElement("br",null),"B = \u230abij\u230b is a q x r matrix",i.a.createElement("br",null),"C = \u230acij\u230b is a p x r matrix"),i.a.createElement("li",null,"(ABC)D = (AB)(CD) = A(BCD) = ....",i.a.createElement("br",null),"However, the order in which we parenthesize the product affects the number of simple arithmetic operations needed to compute the product, or the efficiency. For example, suppose A is a 10 \xd7 30 matrix, B is a 30 \xd7 5 matrix, and C is a 5 \xd7 60 matrix. Then, (AB)C = (10\xd730\xd75) + (10\xd75\xd760) = 1500 + 3000 = 4500 operations",i.a.createElement("br",null),"A(BC) = (30\xd75\xd760) + (10\xd730\xd760) = 9000 + 18000 = 27000 operations."),i.a.createElement("li",null,"when we used the Dynamic programming technique we shall follow some steps.",i.a.createElement("br",null),"Characterize the structure of an optimal solution.",i.a.createElement("br",null),"Recursively de\ufb01ne the value of an optimal solution.",i.a.createElement("br",null),"Compute the value of an optimal solution.",i.a.createElement("br",null),"Construct an optimal solution from computed information."),i.a.createElement("li",null,"Multiplying an i\xd7j and a j\xd7k matrix requires ijk multiplications",i.a.createElement("br",null),"Each element of the product requires j multiplications, and there are ik elements"),i.a.createElement("li",null,"we have matrices of any of order. our goal is find optimal cost multiplication of matrices.when we solve the this kind of problem using DP step 2 we can get",i.a.createElement("br",null),"m[i , j] = min ","{"," m[i , k] + m[i+k , j] + pi-1*pk*pj ","}"," if i ","<"," j\u2026",i.a.createElement("br",null),". where p is dimension of matrix , i \u2264 k ","<"," j \u2026.."),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm",i.a.createElement("br",null),"matOrder(array, n)",i.a.createElement("br",null),"Input \u2212 List of matrices, the number of matrices in the list.",i.a.createElement("br",null),"Output \u2212 Minimum number of matrix multiplication.",i.a.createElement("br",null),"Begin",i.a.createElement("br",null),"define table minMul of size n x n, ",i.a.createElement("br",null),"initially fill with all 0s",i.a.createElement("br",null),"for length := 2 to n, do",i.a.createElement("br",null),"fir i:=1 to n-length, do",i.a.createElement("br",null),"j := i + length \u2013 1",i.a.createElement("br",null),"minMul[i, j] := \u221e",i.a.createElement("br",null),"for k := i to j-1, do",i.a.createElement("br",null),"q := minMul[i, k] + minMul[k+1, j] + array[i-1]*array[k]*array[j]",i.a.createElement("br",null),"if q ","<"," minMul[i, j], then minMul[i, j] := q",i.a.createElement("br",null),"done",i.a.createElement("br",null),"done",i.a.createElement("br",null),"done",i.a.createElement("br",null),"return minMul[1, n-1]",i.a.createElement("br",null),"End")),i.a.createElement("li",null,i.a.createElement("pre",null,'\nLet M[i,j] = the number of multiplications \nrequired for matrix product Ai\xd7\u22ef\xd7Aj\nFor 1\u2264i\u2264j < n\nM[i,i]=0 since no product is required\nThe optimal solution of Ai\xd7Aj..\nmust break at some point, k, with i\u2264k{"<"}j\nThus, M[i,j]=M[i,k]+M[k+1,j]+di\u22121dkdj\nThus, M[i,j]= \n{0 min i\u2264k < j {M [i,k] + M[k+1,j]+di\u22121dkdj} \nif i=j \nif i < j\nThis is a recursive function \n(with exponential complexity)\n\n\nComplexity:\nP(1) = 1\nP(n) = Sum (k=1, n-1) P(k)P(n-k)\nP(n) = \u03a9(fn/n32)\n'))))))))))},de=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"},"Longest Common Subsequence"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Solutions")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"LCS Problem Statement: Given two sequences, find the length of longest subsequence present in both of them. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. For example, \u201cabc\u201d, \u201cabg\u201d, \u201cbdf\u201d, \u201caeg\u201d, \u2018\u201dacefg\u201d, .. etc are subsequences of \u201cabcdefg\u201d."),i.a.createElement("li",null,"In order to find out the complexity of brute force approach, we need to first know the number of possible different subsequences of a string with length n, i.e., find the number of subsequences with lengths ranging from 1,2,..n-1. Recall from theory of permutation and combination that number of combinations with 1 element are nC1. Number of combinations with 2 elements are nC2 and so forth and so on. We know that nC0 + nC1 + nC2 + \u2026 nCn = 2n. So a string of length n has 2n-1 different possible subsequences since we do not consider the subsequence with length 0. This implies that the time complexity of the brute force approach will be O(n * 2n). Note that it takes O(n) time to check if a subsequence is common to both the strings. This time complexity can be improved using dynamic programming."),i.a.createElement("li",null,"The naive solution for this problem is to generate all subsequences of both given sequences and find the longest matching subsequence. This solution is exponential in term of time complexity. Let us see how this problem possesses both important properties of a Dynamic Programming (DP) Problem."),i.a.createElement("li",null,i.a.createElement("strong",null," 1) Optimal Substructure:"),i.a.createElement("br",null),"Let the input sequences be X[0..m-1] and Y[0..n-1] of lengths m and n respectively. And let L(X[0..m-1], Y[0..n-1]) be the length of LCS of the two sequences X and Y. Following is the recursive definition of L(X[0..m-1], Y[0..n-1])."),i.a.createElement("li",null,"If last characters of both sequences match (or X[m-1] == Y[n-1]) then",i.a.createElement("br",null),"L(X[0..m-1], Y[0..n-1]) = 1 + L(X[0..m-2], Y[0..n-2])"),i.a.createElement("li",null,"If last characters of both sequences do not match (or X[m-1] != Y[n-1]) then",i.a.createElement("br",null),"L(X[0..m-1], Y[0..n-1]) = MAX ( L(X[0..m-2], Y[0..n-1]), L(X[0..m-1], Y[0..n-2]) )"),i.a.createElement("li",null,i.a.createElement("strong",null,"Examples:"),i.a.createElement("br",null),"1) Consider the input strings \u201cAGGTAB\u201d and \u201cGXTXAYB\u201d. Last characters match for the strings. So length of LCS can be written as:",i.a.createElement("br",null),"L(\u201cAGGTAB\u201d, \u201cGXTXAYB\u201d) = 1 + L(\u201cAGGTA\u201d, \u201cGXTXAY\u201d)",i.a.createElement("br",null)),i.a.createElement("li",null,i.a.createElement("strong",null,"2) Overlapping Subproblems:"),i.a.createElement("br",null),"Following is simple recursive implementation of the LCS problem. The implementation simply follows the recursive structure mentioned above."),i.a.createElement("li",null,"Time complexity of the above naive recursive approach is O(2^n) in worst case and worst case happens when all characters of X and Y mismatch i.e., length of LCS is 0. Considering the above implementation, following is a partial recursion tree for input strings \u201cABCD\u201d and \u201cAYZX\u201d"),i.a.createElement("li",null,i.a.createElement("img",{src:"https://miro.medium.com/max/1678/1*vUURQpHCEnJJbgU_u15TJQ.png",className:"img-fluid mx-auto"})))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Dynamic Programming Approach")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Let X = ","<"," x1, x2, x3,\u2026, xm ",">"," and Y = ","<","y1, y2, y3,\u2026, yn ",">"," be the sequences. To compute the length of an element the following algorithm is used."),i.a.createElement("li",null,"In this procedure, table C[m, n] is computed in row major order and another table B[m,n] is computed to construct optimal solution."),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm: LCS-Length-Table-Formulation (X, Y)",i.a.createElement("br",null),"m := length(X) ",i.a.createElement("br",null),"n := length(Y) ",i.a.createElement("br",null),"for i = 1 to m do ",i.a.createElement("br",null),"C[i, 0] := 0 ",i.a.createElement("br",null),"for j = 1 to n do ",i.a.createElement("br",null),"C[0, j] := 0 ",i.a.createElement("br",null),"for i = 1 to m do ",i.a.createElement("br",null),"for j = 1 to n do ",i.a.createElement("br",null),"if xi = yj ",i.a.createElement("br",null),"C[i, j] := C[i - 1, j - 1] + 1 ",i.a.createElement("br",null),"B[i, j] := \u2018D\u2019 ",i.a.createElement("br",null),"else ",i.a.createElement("br",null),"if C[i -1, j] \u2265 C[i, j -1] ",i.a.createElement("br",null),"C[i, j] := C[i - 1, j] + 1 ",i.a.createElement("br",null),"B[i, j] := \u2018U\u2019 ",i.a.createElement("br",null),"else ",i.a.createElement("br",null),"C[i, j] := C[i, j - 1]",i.a.createElement("br",null),"B[i, j] := \u2018L\u2019 ",i.a.createElement("br",null),"return C and B",i.a.createElement("br",null))),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm: Print-LCS (B, X, i, j)",i.a.createElement("br",null),"if i = 0 and j = 0 ",i.a.createElement("br",null),"return  ",i.a.createElement("br",null),"if B[i, j] = \u2018D\u2019 ",i.a.createElement("br",null),"Print-LCS(B, X, i-1, j-1) ",i.a.createElement("br",null),"Print(xi) ",i.a.createElement("br",null),"else if B[i, j] = \u2018U\u2019 ",i.a.createElement("br",null),"Print-LCS(B, X, i-1, j) ",i.a.createElement("br",null),"else ",i.a.createElement("br",null),"Print-LCS(B, X, i, j-1) ",i.a.createElement("br",null))),i.a.createElement("li",null,"To populate the table, the outer for loop iterates m times and the inner for loop iterates n times. Hence, the complexity of the algorithm is O(m, n), where m and n are the length of two strings."),i.a.createElement("li",null,i.a.createElement("img",{src:"https://i1.wp.com/algorithms.tutorialhorizon.com/files/2015/06/LCS-Printing-Result.png",className:"img-fluid mx-auto",style:{height:"300px"}}))))))))))},Ee=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"},"Greedy Algorithm "))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Greedy Algorithm Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Among all the algorithmic approaches, the simplest and straightforward approach is the Greedy method. In this approach, the decision is taken on the basis of current available information without worrying about the effect of the current decision in future."),i.a.createElement("li",null,"In this method, we have to find out the best method/option out of many present ways.",i.a.createElement("br",null),"In this approach/method we focus on the first stage and decide the output, don't think about the future."),i.a.createElement("li",null,"Greedy algorithms build a solution part by part, choosing the next part in such a way, that it gives an immediate benefit. This approach never reconsiders the choices taken previously. This approach is mainly used to solve optimization problems. Greedy method is easy to implement and quite efficient in most of the cases."),i.a.createElement("li",null,"greedy algorithm may provide a solution that is close to optimal. A greedy algorithm works if a problem exhibits the following two properties:",i.a.createElement("ol",null,i.a.createElement("li",null,'Greedy Choice Property: A globally optimal solution can be reached at by creating a locally optimal solution. In other words, an optimal solution can be obtained by creating "greedy" choices.'),i.a.createElement("li",null,"Optimal substructure: Optimal solutions contain optimal subsolutions. In other words, answers to subproblems of an optimal solution are optimal."))),i.a.createElement("li",null,"Components of Greedy Algorithm",i.a.createElement("br",null),i.a.createElement("ol",null,i.a.createElement("li",null,"A candidate set \u2212 A solution is created from this set."),i.a.createElement("li",null,"A selection function \u2212 Used to choose the best candidate to be added to the solution."),i.a.createElement("li",null,"A feasibility function \u2212 Used to determine whether a candidate can be used to contribute to the solution."),i.a.createElement("li",null,"An objective function \u2212 Used to assign a value to a solution or a partial solution."),i.a.createElement("li",null,"A solution function \u2212 Used to indicate whether a complete solution has been reached."))),i.a.createElement("li",null,i.a.createElement("strong",null,"Steps for achieving a Greedy Algorithm are:"),i.a.createElement("br",null),"Feasible: Here we check whether it satisfies all possible constraints or not, to obtain at least one solution to our problems.",i.a.createElement("br",null),"Local Optimal Choice: In this, the choice should be the optimum which is selected from the currently available",i.a.createElement("br",null),"Unalterable: Once the decision is made, at any subsequence step that option is not altered.",i.a.createElement("br",null)))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{xs:12},i.a.createElement(k.a,{className:"",style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Differentiate between Dynamic Programming and Greedy Method")),i.a.createElement(M.a,null,i.a.createElement(O.a,{responsive:!0},i.a.createElement("tr",null,i.a.createElement("td",null,i.a.createElement("h5",{className:"title"},"Dynamic Programming")),i.a.createElement("td",null,i.a.createElement("h5",{className:"title"},"Greedy Method"))),i.a.createElement("tr",null,i.a.createElement("td",null,"Dynamic Programming is used to obtain the optimal solution."),i.a.createElement("td",null,"Greedy Method is also used to get the optimal solution")),i.a.createElement("tr",null,i.a.createElement("td",null,"In Dynamic Programming, we choose at each step, but the choice may depend on the solution to sub-problems."),i.a.createElement("td",null,"In a greedy Algorithm, we make whatever choice seems best at the moment and then solve the sub-problems arising after the choice is made.")),i.a.createElement("tr",null,i.a.createElement("td",null,"Less efficient as compared to a greedy approach"),i.a.createElement("td",null,"More efficient as compared to a greedy approach")),i.a.createElement("tr",null,i.a.createElement("td",null,"It is guaranteed that Dynamic Programming will generate an optimal solution using Principle of Optimality."),i.a.createElement("td",null,"In Greedy Method, there is no such guarantee of getting Optimal Solution.")),i.a.createElement("tr",null,i.a.createElement("td",null,"Example: 0/1 Knapsack"),i.a.createElement("td",null,"Example: Fractional Knapsack"))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Making Change Problem")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Making Change problem is used to minimum number of coins (of certain denominations) that add up to a given amount of money(Total money)."),i.a.createElement("li",null,"For some type of coin system a greedy approach works. The values of coins will be like ",50,"."),i.a.createElement("li",null,"In our algorithm we always choose the biggest denomination, subtract the all possible values and going to the next denomination.",i.a.createElement("br",null),"so,we will use greedy algorithm to give the least amount of coins.",i.a.createElement("br",null),"suppose a customer wants change of 41 Rs"),i.a.createElement("li",null,"41\u201325=16 ","->","  [25] so,take coin of 25.",i.a.createElement("br",null),"16\u201310=6 ","->"," [25][10]",i.a.createElement("br",null),"6\u20135=1 ","->"," [25][10][5]",i.a.createElement("br",null),"1\u20131=0 ","->"," [25][10][5][1]",i.a.createElement("br",null),"so here,is the optimal solution of 41 Rs change is 25,10,5,1=41 Rs."),i.a.createElement("li",null,"But always That is not the case.",i.a.createElement("br",null),"Ex:-2",i.a.createElement("br",null),"The values of coins will be like ",25,".",i.a.createElement("br",null),"41\u201325=16 ","=>","[25]",i.a.createElement("br",null),"16\u201310=6 ","=>","[25][10]",i.a.createElement("br",null),"6\u20134=2 ","=>","[25][10][4]",i.a.createElement("br",null),"2- ??",i.a.createElement("br",null),"so here is the problem,or error message.",i.a.createElement("br",null),"So here is the optimal solution is [25][4][4][4][4] =41 Rs."),i.a.createElement("br",null),i.a.createElement("li",null,"Algorithm",i.a.createElement("br",null),i.a.createElement("code",null,i.a.createElement("ol",null,i.a.createElement("li",null,"Sort the array of coins in decreasing order."),i.a.createElement("li",null,"Initialize result as empty."),i.a.createElement("li",null,"Find the largest denomination that is smaller than current amount."),i.a.createElement("li",null,"Add found denomination to result. Subtract value of found denomination from amount."),i.a.createElement("li",null,"If amount becomes 0, then print result."),i.a.createElement("li",null,"Else repeat steps 3 and 4 for new value of V.")))),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement(te.a,null,"int coins[COINS] = ",i.a.createElement("br",null),"{"," 1, 2, 5, 10, 20, 50, 100, 200, 2000 ","}","; ",i.a.createElement("br",null),"void findMin(int cost) ",i.a.createElement("br",null),"{","int coinList[MAX] = ","{"," 0 ","}","; ",i.a.createElement("br",null),"int i, k = 0; ",i.a.createElement("br",null),"for (i = COINS - 1; i ",">","= 0; i--) ","{ ",i.a.createElement("br",null),"while (cost ",">","= coins[i]) ","{ ",i.a.createElement("br",null),"cost -= coins[i]; ",i.a.createElement("br",null),"coinList[k++] = coins[i];",i.a.createElement("br",null),"}"," ",i.a.createElement("br",null),"}","for (i = 0; i ","<"," k; i++) ","{ ",i.a.createElement("br",null),'printf("%d ", coinList[i]); ',i.a.createElement("br",null),"}"," ",i.a.createElement("br",null),"return; ",i.a.createElement("br",null),"}"," ",i.a.createElement("br",null))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"An Activity Selection Problem")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"The activity selection problem is a mathematical optimization problem. Our first illustration is the problem of scheduling a resource among several challenge activities. We find a greedy algorithm provides a well designed and simple method for selecting a maximum- size set of manually compatible activities."),i.a.createElement("li",null,"Suppose S = ","{","1, 2....n","}",' is the set of n proposed activities. The activities share resources which can be used by only one activity at a time, e.g., Tennis Court, Lecture Hall, etc. Each Activity "i" has start time si and a finish time fi, where si \u2264fi.',i.a.createElement("br",null),'If selected activity "i" take place meanwhile the half-open time interval [si,fi).',i.a.createElement("br",null),"Activities i and j are compatible if the intervals (si, fi) and [si, fi) do not overlap (i.e. i and j are compatible if si \u2265fi or si \u2265fi). ",i.a.createElement("br",null),"The activity-selection problem chosen the maximum- size set of mutually consistent activities.",i.a.createElement("br",null)),i.a.createElement("li",null,i.a.createElement("code",null,"GREEDY- ACTIVITY SELECTOR (s, f)",i.a.createElement("br",null),"1. n \u2190 length [s]",i.a.createElement("br",null),"2. A \u2190 ","{1}",i.a.createElement("br",null),"3. j \u2190 1.",i.a.createElement("br",null),"4. for i \u2190 2 to n",i.a.createElement("br",null),"5. do if si \u2265 fi",i.a.createElement("br",null),"6. then A \u2190 A \u222a ","{i}",i.a.createElement("br",null),"7. j \u2190 i",i.a.createElement("br",null),"8. return A",i.a.createElement("br",null))),i.a.createElement("li",null,i.a.createElement("strong",null,"Example 1 :"),i.a.createElement("br",null),"Consider the following 3 activities sorted by by finish time.",i.a.createElement("br",null),"start[]  =  ","{10, 12, 20}",";",i.a.createElement("br",null),"finish[] =  ","{20, 25, 30}",";",i.a.createElement("br",null),"A person can perform at most two activities. The ",i.a.createElement("br",null),"maximum set of activities that can be executed is ","{0, 2}","  [ These are indexes in start[] and finish[] ]"),i.a.createElement("li",null,i.a.createElement("strong",null,"Example 2 :",i.a.createElement("br",null)),"Consider the following 6 activities sorted by by finish time.",i.a.createElement("br",null),"start[]  = ","{1, 3, 0, 5, 8, 5}"," ;",i.a.createElement("br",null),"finish[] = ","{2, 4, 6, 7, 9, 9}"," ;",i.a.createElement("br",null),"A person can perform at most four activities. The maximum set of activities that can be executed is ","{0, 1, 3, 4}"," ",i.a.createElement("br",null),"[ These are indexes in start[] and finish[] ]"),i.a.createElement("li",null,"1) Sort the activities according to their finishing time",i.a.createElement("br",null),"2) Select the first activity from the sorted array and print it.",i.a.createElement("br",null),"3) Do following for remaining activities in the sorted array. If the start time of this activity is greater than or equal to the finish time of previously selected activity then select this activity and print it."),i.a.createElement("li",null,i.a.createElement("strong",null,"Time Complexity :")," ",i.a.createElement("br",null),"It takes O(n log n) time if input activities may not be sorted. It takes O(n) time when it is given that input activities are always sorted."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Activity or Task Scheduling Problem")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"This is the dispute of optimally scheduling unit-time tasks on a single processor, where each job has a deadline and a penalty that necessary be paid if the deadline is missed."),i.a.createElement("li",null,"A unit-time task is a job, such as a program to be rush on a computer that needed precisely one unit of time to complete."),i.a.createElement("li",null,"Given a finite set S of unit-time tasks, a schedule for S is a permutation of S specifying the order in which to perform these tasks. The first task in the schedule starts at time 0 and ends at time 1; the second task begins at time 1 and finishes at time 2, and so on."),i.a.createElement("li",null,"The dispute of scheduling unit-time tasks with deadlines and penalties for each processor has the following inputs:",i.a.createElement("ul",null,i.a.createElement("li",null,"a set S = ","{","1, 2, 3.....n","}"," of n unit-time tasks.",i.a.createElement("br",null),"a set of n integer deadlines d1 d2 d3...dn such that di satisfies 1\u2264 di \u2264 n and task i is supposed to finish by time di and",i.a.createElement("br",null),"a set of n non-negative weights or penalties w1 w2....wn such that we incur a penalty of wi if task i is not finished by time di, and we incurred no penalty if a task finishes by its deadline."))),i.a.createElement("li",null,"A task is late in this schedule if it finished after its deadline. Otherwise, the task is early in the schedule. An arbitrary schedule can consistently be put into early-first form, in which the first tasks precede the late tasks, i.e., if some new task x follows some late task y, then we can switch the position of x and y without affecting x being early or y being late."),i.a.createElement("li",null,"An arbitrary schedule can always be put into a canonical form in which first tasks precede the late tasks, and first tasks are scheduled in order of nondecreasing deadlines."),i.a.createElement("li",null,"A set A of tasks is independent if there exists a schedule for the particular tasks such that no tasks are late. So the set of first tasks for a schedule forms an independent set of tasks 'l' denote the set of all independent set of tasks."),i.a.createElement("li",null,"For any set of tasks A, A is independent if for t = 0, 1, 2.....n we have Nt(A) \u2264 t where Nt(A) denotes the number of tasks in A whose deadline is t or prior, i.e. if the tasks in A are expected in order of monotonically growing deadlines, then no task is late."),i.a.createElement("li",null,i.a.createElement("img",{src:"https://iq.opengenus.org/content/images/2019/03/Example2-2.png",className:"img-fluid mx-auto"})),i.a.createElement("li",null,i.a.createElement("code",null,"Activity-Selection(Activity, start, finish)",i.a.createElement("br",null),"Sort Activity by finish times stored in finish",i.a.createElement("br",null),"Selected =","{Activity[1]}"," ",i.a.createElement("br",null),"n = Activity.length",i.a.createElement("br",null),"j = 1",i.a.createElement("br",null),"for i = 2 to n:",i.a.createElement("br",null),"if start[i] \u2265 finish[j]:",i.a.createElement("br",null),"Selected = Selected U ","{Activity[i]}"," ",i.a.createElement("br",null),"j = i",i.a.createElement("br",null),"return Selected"))))))))))},pe=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," HuffMan Coding (Greedy Approach)"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Huffman Codes")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"(i) Data can be encoded efficiently using Huffman Codes."),i.a.createElement("li",null,"(ii) It is a widely used and beneficial technique for compressing data. ("),i.a.createElement("li",null,"iii) Huffman's greedy algorithm uses a table of the frequencies of occurrences of each character to build up an optimal way of representing each character as a binary string."),i.a.createElement("li",null,"Suppose we have 105 characters in a data file. Normal Storage: 8 bits per character (ASCII) - 8 x 105 bits in a file. But we want to compress the file and save it compactly. Suppose only six characters appear in the file:"))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Prefix Codes, means the codes (bit sequences) are assigned in such a way that the code assigned to one character is not the prefix of code assigned to any other character. This is how Huffman Coding makes sure that there is no ambiguity when decoding the generated bitstream. Let us understand prefix codes with a counter example. Let there be four characters a, b, c and d, and their corresponding variable length codes be 00, 01, 0 and 1. This coding leads to ambiguity because code assigned to c is the prefix of codes assigned to a and b. If the compressed bit stream is 0001, the de-compressed output may be \u201ccccd\u201d or \u201cccb\u201d or \u201cacd\u201d or \u201cab\u201d."),i.a.createElement("li",null,"Huffman Coding is generally useful to compress the data in which there are frequently occurring characters."),i.a.createElement("li",null,"There are mainly two major parts in Huffman Coding",i.a.createElement("br",null),"1) Build a Huffman Tree from input characters.",i.a.createElement("br",null),"2) Traverse the Huffman Tree and assign codes to characters."),i.a.createElement("li",null,"Steps to build Huffman Tree",i.a.createElement("br",null),"Input is an array of unique characters along with their frequency of occurrences and output is Huffman Tree.",i.a.createElement("ul",null,i.a.createElement("li",null,"1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. The value of frequency field is used to compare two nodes in min heap. Initially, the least frequent character is at root)"),i.a.createElement("li",null,"2. Extract two nodes with the minimum frequency from the min heap."),i.a.createElement("li",null,"3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies. Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap."),i.a.createElement("li",null,"4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete."),i.a.createElement("li",null,i.a.createElement("strong",null,"Huffman Coding Complexity"),i.a.createElement("br",null),"The time complexity for encoding each unique character based on its frequency is O(nlog n).",i.a.createElement("br",null),"Extracting minimum frequency from the priority queue takes place 2*(n-1) times and its complexity is O(log n). Thus the overall complexity is O(nlog n)."))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Example")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("code",null,i.a.createElement("ul",null,i.a.createElement("li",null,"Input:",i.a.createElement("br",null),"A string with different characters, say \u201cACCEBFFFFAAXXBLKE\u201d"),i.a.createElement("li",null,"Output: Code for different characters:",i.a.createElement("br",null),"Data: K, Frequency: 1, Code: 0000",i.a.createElement("br",null),"Data: L, Frequency: 1, Code: 0001",i.a.createElement("br",null),"Data: E, Frequency: 2, Code: 001",i.a.createElement("br",null),"Data: F, Frequency: 4, Code: 01",i.a.createElement("br",null),"Data: B, Frequency: 2, Code: 100",i.a.createElement("br",null),"Data: C, Frequency: 2, Code: 101",i.a.createElement("br",null),"Data: X, Frequency: 2, Code: 110",i.a.createElement("br",null),"Data: A, Frequency: 3, Code: 111")))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Algorithm")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("code",null,i.a.createElement("ul",null,i.a.createElement("li",null,"Algorithm",i.a.createElement("br",null),"huffmanCoding(string)"),i.a.createElement("li",null,"Input: A string with different characters.",i.a.createElement("br",null),"Output: The codes for each individual characters."),i.a.createElement("li",null,"Begin",i.a.createElement("br",null),"define a node with character, frequency, left and right child of the node for Huffman tree.",i.a.createElement("br",null),"create a list \u2018freq\u2019 to store frequency of each character, initially, all are 0",i.a.createElement("br",null),"for each character c in the string do",i.a.createElement("br",null),"increase the frequency for character ch in freq list.",i.a.createElement("br",null),"done",i.a.createElement("br",null),"for all type of character ch do",i.a.createElement("br",null),"if the frequency of ch is non zero then",i.a.createElement("br",null),"add ch and its frequency as a node of priority queue Q.",i.a.createElement("br",null),"done",i.a.createElement("br",null),"while Q is not empty do",i.a.createElement("br",null),"remove item from Q and assign it to left child of node",i.a.createElement("br",null),"remove item from Q and assign to the right child of node",i.a.createElement("br",null),"traverse the node to find the assigned code",i.a.createElement("br",null),"done",i.a.createElement("br",null),"End")),i.a.createElement("ul",null,i.a.createElement("li",null,"traverseNode(n: node, code)",i.a.createElement("br",null),"Input: ",i.a.createElement("br",null),"The node n of the Huffman tree, and the code assigned from the previous call",i.a.createElement("br",null),"Output: ",i.a.createElement("br",null),"Code assigned with each character",i.a.createElement("br",null),"if a left child of node n \u2260\u03c6 then",i.a.createElement("br",null),"traverseNode(leftChild(n), code+\u20190\u2019)",i.a.createElement("br",null),"traverseNode(rightChild(n), code+\u20191\u2019)    ",i.a.createElement("br",null),"else",i.a.createElement("br",null),"display the character and data of current node.")))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Example")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"data:image/png;base64,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",className:"mx-auto img-fluid"}))))))))},ge=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Spanning Tree "))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Spanning Tree Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"A spanning tree is a subset of an undirected Graph that has all the vertices connected by minimum number of edges."),i.a.createElement("li",null,"If all the vertices are connected in a graph, then there exists at least one spanning tree. In a graph, there may exist more than one spanning tree."),i.a.createElement("li",null,i.a.createElement("strong",null,"  Properties"),i.a.createElement("br",null),"A spanning tree does not have any cycle.",i.a.createElement("br",null),"Any vertex can be reached from any other vertex."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Example Of Spanning Tree")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcT9WFP_wkIojhvMJ-ND5aeOk3sX46A8LtE31Q&usqp=CAU",className:"mx-auto img-fluid"})))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Minimum Spanning Tree")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Given a connected and undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the vertices together. A single graph can have many different spanning trees. A minimum spanning tree (MST) or minimum weight spanning tree for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree."),i.a.createElement("li",null,"How many edges does a minimum spanning tree has?"),i.a.createElement("li",null,"A minimum spanning tree has (V \u2013 1) edges where V is the number of vertices in the given graph."),i.a.createElement("li",null,i.a.createElement("img",{src:"https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcTJk8OJrJSWQ1hx3rvCLyHv86Ys2YkGCcoNBw&usqp=CAU",className:"mx-auto img-fluid"})),i.a.createElement("li",null,"Application of Minimum Spanning Tree",i.a.createElement("ul",null,i.a.createElement("li",null,"Consider n stations are to be linked using a communication network & laying of communication links between any two stations involves a cost."),i.a.createElement("li",null,"The ideal solution would be to extract a subgraph termed as minimum cost spanning tree."),i.a.createElement("li",null,"Suppose you want to construct highways or railroads spanning several cities then we can use the concept of minimum spanning trees."),i.a.createElement("li",null,"Designing Local Area Networks."),i.a.createElement("li",null,"Laying pipelines connecting offshore drilling sites, refineries and consumer markets. Suppose you want to apply a set of houses with",i.a.createElement("ul",null,i.a.createElement("li",null,"Electric Power"),i.a.createElement("li",null,"Water"),i.a.createElement("li",null,"Telephone lines"),i.a.createElement("li",null,"Sewage lines"))))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"algorithms for finding the Minimum Spanning Tree")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("h5",null,"  Kruskal\u2019s Algorithm"),i.a.createElement("li",null,"Kruskal\u2019s Algorithm builds the spanning tree by adding edges one by one into a growing spanning tree. Kruskal's algorithm follows greedy approach as in each iteration it finds an edge which has least weight and add it to the growing spanning tree."),i.a.createElement("li",null,"An algorithm to construct a Minimum Spanning Tree for a connected weighted graph. It is a Greedy Algorithm. The Greedy Choice is to put the smallest weight edge that does not because a cycle in the MST constructed so far."),i.a.createElement("li",null,"Steps for finding MST using Kruskal's Algorithm:",i.a.createElement("ol",null,i.a.createElement("li",null,"Arrange the edge of G in order of increasing weight."),i.a.createElement("li",null,"Starting only with the vertices of G and proceeding sequentially add each edge which does not result in a cycle, until (n - 1) edges are used."),i.a.createElement("li",null,"EXIT."))),i.a.createElement("li",null,i.a.createElement("code",null,"MST- KRUSKAL (G, w)",i.a.createElement("br",null),"1. A \u2190 \u2205",i.a.createElement("br",null),"2. for each vertex v \u2208 V [G]",i.a.createElement("br",null),"3. do MAKE - SET (v)",i.a.createElement("br",null),"4. sort the edges of E into non decreasing order by weight w",i.a.createElement("br",null),"5. for each edge (u, v) \u2208 E, taken in non decreasing order by weight",i.a.createElement("br",null),"6. do if FIND-SET (\u03bc) \u2260 if FIND-SET (v)",i.a.createElement("br",null),"7. then A  \u2190  A \u222a ","{(u, v)}",i.a.createElement("br",null),"8. UNION (u, v)",i.a.createElement("br",null),"9. return A",i.a.createElement("br",null))),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("strong",null," Analysis:"),i.a.createElement("br",null),"Where E is the number of edges in the graph and V is the number of vertices, Kruskal's Algorithm can be shown to run in O (E log E) time, or simply, O (E log V) time, all with simple data structures. These running times are equivalent because:"),i.a.createElement("li",null,"E is at most V2 and log V2= 2 x log V is O (log V).",i.a.createElement("br",null),"If we ignore isolated vertices, which will each their components of the minimum spanning tree, V \u2264 2 E, so log V is O (log E)."),i.a.createElement("li",null,"Thus the total time is",i.a.createElement("strong",null,i.a.createElement("i",null,"O (E log E) = O (E log V). "))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Example:")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"https://aquarchitect.github.io/swift-algorithm-club/Minimum%20Spanning%20Tree/Images/kruskal.png",className:"mx-auto img-fluid"})))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Prims Algorithm")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Prim\u2019s Algorithm also use Greedy approach to find the minimum spanning tree. In Prim\u2019s Algorithm we grow the spanning tree from a starting position. Unlike an edge in Kruskal's, we add vertex to the growing spanning tree in Prim's."),i.a.createElement("li",null,"It is a greedy algorithm. It starts with an empty spanning tree. The idea is to maintain two sets of vertices: Contain vertices already included in MST.",i.a.createElement("br",null),"Contain vertices not yet included.",i.a.createElement("br",null)),i.a.createElement("li",null,"At every step, it considers all the edges and picks the minimum weight edge. After picking the edge, it moves the other endpoint of edge to set containing MST."),i.a.createElement("li",null,"A group of edges that connects two set of vertices in a graph is called cut in graph theory. So, at every step of Prim\u2019s algorithm, we find a cut (of two sets, one contains the vertices already included in MST and other contains rest of the vertices), pick the minimum weight edge from the cut and include this vertex to MST Set (the set that contains already included vertices)."),i.a.createElement("li",null,"The idea behind Prim\u2019s algorithm is simple, a spanning tree means all vertices must be connected. So the two disjoint subsets (discussed above) of vertices must be connected to make a Spanning Tree. And they must be connected with the minimum weight edge to make it a Minimum Spanning Tree."),i.a.createElement("li",null,"Algorithm",i.a.createElement("ul",null,i.a.createElement("li",null,"1) Create a set mstSet that keeps track of vertices already included in MST."),i.a.createElement("li",null,"2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first."),i.a.createElement("li",null,"3) While mstSet doesn\u2019t include all vertices",i.a.createElement("ul",null,i.a.createElement("li",null,".a) Pick a vertex u which is not there in mstSet and has minimum key value."),i.a.createElement("li",null,".b) Include u to mstSet."),i.a.createElement("li",null,"c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v The idea of using key values is to pick the minimum weight edge from cut. The key values are used only for vertices which are not yet included in MST, the key value for these vertices indicate the minimum weight edges connecting them to the set of vertices included in MST."))),i.a.createElement("li",null,"Prim's Algorithm pseudocode",i.a.createElement("br",null),"The pseudocode for prim's algorithm shows how we create two sets of vertices U and V-U. U contains the list of vertices that have been visited and V-U the list of vertices that haven't. One by one, we move vertices from set V-U to set U by connecting the least weight edge."),i.a.createElement("li",null,i.a.createElement("code",null,"T = \u2205;",i.a.createElement("br",null),"U = ","{ 1 }",";",i.a.createElement("br",null),"while (U \u2260 V)",i.a.createElement("br",null),"let (u, v) be the lowest cost edge such that u \u2208 U and v \u2208 V - U;",i.a.createElement("br",null),"T = T \u222a ","{(u, v)}",i.a.createElement("br",null),"U = U \u222a ","{v}",i.a.createElement("br",null))))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Example :")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"https://aquarchitect.github.io/swift-algorithm-club/Minimum%20Spanning%20Tree/Images/prim.png",className:"mx-auto img-fluid"})))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Dijkstra\u2019s shortest path algorithm")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Given a graph and a source vertex in the graph, find shortest paths from source to all vertices in the given graph."),i.a.createElement("li",null,"Dijkstra\u2019s algorithm is very similar to Prim\u2019s algorithm for minimum spanning tree. Like Prim\u2019s MST, we generate a SPT (shortest path tree) with given source as root. We maintain two sets, one set contains vertices included in shortest path tree, other set includes vertices not yet included in shortest path tree. At every step of the algorithm, we find a vertex which is in the other set (set of not yet included) and has a minimum distance from the source."),i.a.createElement("li",null,"Below are the detailed steps used in Dijkstra\u2019s algorithm to find the shortest path from a single source vertex to all other vertices in the given graph. Algorithm"),i.a.createElement("li",null,"1) Create a set sptSet (shortest path tree set) that keeps track of vertices included in shortest path tree, i.e., whose minimum distance from source is calculated and finalized. Initially, this set is empty.",i.a.createElement("br",null),"2) Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE. Assign distance value as 0 for the source vertex so that it is picked first.",i.a.createElement("br",null),"3) While sptSet doesn\u2019t include all vertices",i.a.createElement("ul",null,i.a.createElement("li",null,"\u2026.a) Pick a vertex u which is not there in sptSet and has minimum distance value."),i.a.createElement("li",null,"\u2026.b) Include u to sptSet."),i.a.createElement("li",null,"\u2026.c) Update distance value of all adjacent vertices of u. To update the distance values, iterate through all adjacent vertices. For every adjacent vertex v, if sum of distance value of u (from source) and weight of edge u-v, is less than the distance value of v, then update the distance value of v.")))),i.a.createElement("ul",null,i.a.createElement("li",null,"1) The code calculates shortest distance, but doesn\u2019t calculate the path information. We can create a parent array, update the parent array when distance is updated (like prim\u2019s implementation) and use it show the shortest path from source to different vertices."),i.a.createElement("li",null,"2) The code is for undirected graph, same dijkstra function can be used for directed graphs also."),i.a.createElement("li",null,"3) The code finds shortest distances from source to all vertices. If we are interested only in shortest distance from the source to a single target, we can break the for the loop when the picked minimum distance vertex is equal to target (Step 3.a of the algorithm)."),i.a.createElement("li",null,"4) Time Complexity of the implementation is O(V^2). If the input graph is represented using adjacency list, it can be reduced to O(E log V) with the help of binary heap. Please see Dijkstra\u2019s Algorithm for Adjacency List Representation for more details."),i.a.createElement("li",null,"5) Dijkstra\u2019s algorithm doesn\u2019t work for graphs with negative weight cycles, it may give correct results for a graph with negative edges. For graphs with negative weight edges and cycles, Bellman\u2013Ford algorithm can be used, we will soon be discussing it as a separate post."),i.a.createElement("li",null,i.a.createElement("code",null,"function dijkstra(G, S) ",i.a.createElement("br",null),"for each vertex V in G",i.a.createElement("br",null),"distance[V] ","<-"," infinite",i.a.createElement("br",null),"previous[V] ","<-"," NULL",i.a.createElement("br",null),"If V != S, add V to Priority Queue Q",i.a.createElement("br",null),"distance[S] ","<-"," 0",i.a.createElement("br",null),"while Q IS NOT EMPTY",i.a.createElement("br",null),"U ","<-"," Extract MIN from Q",i.a.createElement("br",null),"for each unvisited neighbour V of U",i.a.createElement("br",null),"tempDistance ","<-"," distance[U] + edge_weight(U, V)",i.a.createElement("br",null),"if tempDistance ","<"," distance[V]",i.a.createElement("br",null),"distance[V] ","<-"," tempDistance",i.a.createElement("br",null),"previous[V] ","<-"," U",i.a.createElement("br",null),"return distance[], previous[]")))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Example ")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"https://d2vlcm61l7u1fs.cloudfront.net/media%2Fdb8%2Fdb86637b-3405-4b94-ad2f-28780cd38e68%2FphpOVcfId.png",className:"img-fluid mx-auto"}))))))))},be=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"},"Graph Data Structure And Algorithms"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"A Graph is a non-linear data structure consisting of nodes and edges. The nodes are sometimes also referred to as vertices and the edges are lines or arcs that connect any two nodes in the graph. More formally a Graph can be defined as,"),i.a.createElement("li",null,"A Graph consists of a finite set of vertices(or nodes) and set of Edges which connect a pair of nodes."),i.a.createElement("li",null,"Graphs are used to solve many real-life problems. Graphs are used to represent networks. The networks may include paths in a city or telephone network or circuit network. Graphs are also used in social networks like linkedIn, Facebook. For example, in Facebook, each person is represented with a vertex(or node). Each node is a structure and contains information like person id, name, gender, locale etc."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Directed and Undirected Graphs")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Undirected graphs have edges that do not have a direction. The edges indicate a two-way relationship, in that each edge can be traversed in both directions. This figure shows a simple undirected graph with three nodes and three edges."),i.a.createElement("li",null,"Directed graphs have edges with direction. The edges indicate a one-way relationship, in that each edge can only be traversed in a single direction. This figure shows a simple directed graph with three nodes and two edges."),i.a.createElement("li",null,i.a.createElement("img",{src:"data:image/png;base64,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",className:"mx-auto img-fluid"})))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Graph traversal")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Traversing a graph simply means to follow it from one point to another in a structured format. There are a number of algorithms that allow us to perfom this in the most efficient way possible, but the most basic way to visit all the vertices in a graph is breadth and depth first traversal."),i.a.createElement("li",null,"Inorder traversal ",i.a.createElement("br",null),"First, visit all the nodes in the left subtree ",i.a.createElement("br",null),"Then the root node ",i.a.createElement("br",null),"Visit all the nodes in the right subtree ",i.a.createElement("br",null),i.a.createElement("code",null,"inorder(root-",">","left) ",i.a.createElement("br",null),"display(root-",">","data) ",i.a.createElement("br",null),"inorder(root-",">","right)")),i.a.createElement("li",null,"Preorder traversal",i.a.createElement("br",null),"Visit root node",i.a.createElement("br",null),"Visit all the nodes in the left subtree",i.a.createElement("br",null),"Visit all the nodes in the right subtree",i.a.createElement("br",null),i.a.createElement("code",null,"display(root-",">","data)",i.a.createElement("br",null),"preorder(root-",">","left)",i.a.createElement("br",null),"preorder(root-",">","right)",i.a.createElement("br",null))),i.a.createElement("li",null,"Postorder traversal",i.a.createElement("br",null),"Visit all the nodes in the left subtree",i.a.createElement("br",null),"Visit all the nodes in the right subtree",i.a.createElement("br",null),"Visit the root node",i.a.createElement("br",null),i.a.createElement("code",null,"postorder(root","->","left)",i.a.createElement("br",null),"postorder(root","->","right)",i.a.createElement("br",null),"display(root","->","data)",i.a.createElement("br",null))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Example ")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"https://acm.cs.nthu.edu.tw/media/uploads/2016/03/01/treeorder_0bS4zvh.jpg",className:"img-fluid mx-auto"})))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"DFS & BFS")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"DFS traversal of a graph produces a spanning tree as final result. Spanning Tree is a graph without loops. We use Stack data structure with maximum size of total number of vertices in the graph to implement DFS traversal."),i.a.createElement("li",null,"Step 1 - Define a Stack of size total number of vertices in the graph.",i.a.createElement("br",null),"Step 2 - Select any vertex as starting point for traversal. Visit that vertex and push it on to the Stack.",i.a.createElement("br",null),"Step 3 - Visit any one of the non-visited adjacent vertices of a vertex which is at the top of stack and push it on to the stack.",i.a.createElement("br",null),"Step 4 - Repeat step 3 until there is no new vertex to be visited from the vertex which is at the top of the stack.",i.a.createElement("br",null),"Step 5 - When there is no new vertex to visit then use back tracking and pop one vertex from the stack.",i.a.createElement("br",null),"Step 6 - Repeat steps 3, 4 and 5 until stack becomes Empty.",i.a.createElement("br",null),"Step 7 - When stack becomes Empty, then produce final spanning tree by removing unused edges from the graph")),i.a.createElement("ul",null,i.a.createElement("li",null,"BFS traversal of a graph produces a spanning tree as final result. Spanning Tree is a graph without loops. We use Queue data structure with maximum size of total number of vertices in the graph to implement BFS traversal."),i.a.createElement("li",null,"Step 1 - Define a Queue of size total number of vertices in the graph. ",i.a.createElement("br",null),"Step 2 - Select any vertex as starting point for traversal. Visit that vertex and insert it into the Queue.",i.a.createElement("br",null),"Step 3 - Visit all the non-visited adjacent vertices of the vertex which is at front of the Queue and insert them into the Queue.",i.a.createElement("br",null),"Step 4 - When there is no new vertex to be visited from the vertex which is at front of the Queue then delete that vertex.",i.a.createElement("br",null),"Step 5 - Repeat steps 3 and 4 until queue becomes empty.",i.a.createElement("br",null),"Step 6 - When queue becomes empty, then produce final spanning tree by removing unused edges from the graph"))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Example")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"data:image/png;base64,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",className:"mx-auto img-fluid"})))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Topological Search")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge u v, vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG."),i.a.createElement("li",null,"For example, a topological sorting of the following graph is \u201c5 4 2 3 1 0\u201d. There can be more than one topological sorting for a graph. For example, another topological sorting of the following graph is \u201c4 5 2 3 1 0\u201d. The first vertex in topological sorting is always a vertex with in-degree as 0 (a vertex with no incoming edges)."),i.a.createElement("li",null,"In topological sorting, we use a temporary stack. We don\u2019t print the vertex immediately, we first recursively call topological sorting for all its adjacent vertices, then push it to a stack. Finally, print contents of the stack. Note that a vertex is pushed to stack only when all of its adjacent vertices (and their adjacent vertices and so on) are already in the stack."),i.a.createElement("li",null,"Complexity Analysis: ",i.a.createElement("br",null),"Time Complexity: O(V+E). The above algorithm is simply DFS with an extra stack. So time complexity is the same as DFS which is.",i.a.createElement("br",null),"Auxiliary space: O(V). The extra space is needed for the stack."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Example ::")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"data:image/png;base64,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",className:"mx-auto img-fluid"})))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Articulation Point")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"A vertex in an undirected connected graph is an articulation point (or cut vertex) iff removing it (and edges through it) disconnects the graph. Articulation points represent vulnerabilities in a connected network \u2013 single points whose failure would split the network into 2 or more components. They are useful for designing reliable networks."),i.a.createElement("li",null,"For a disconnected undirected graph, an articulation point is a vertex removing which increases number of connected components."),i.a.createElement("li",null,"These are those points in the graph whose removal leaves the graph disconnected. It is also called separation point. An articulation point is a vertex v of graph G, such that deletion of v, together with all its edges will disconnect the graph and results in G'.where G'should have at least two components Example"),i.a.createElement("li",null,"These are those points in the graph whose removal leaves the graph disconnected. It is also called separation point. An articulation point is a vertex v of graph G, such that deletion of v, together with all its edges will disconnect the graph and results in G'.where G'should have at least two components Example"),i.a.createElement("li",null,i.a.createElement("img",{src:"https://www.techgig.com/files/nicUploads/666856491255457.png",className:"mx-auto img-fluid"})),i.a.createElement("li",null,"Here in above diagram B is the articulation point. Removal of B and its edges results in graph G with 4 disconnected components A,C,D,E."),i.a.createElement("li",null,"The above function is simple DFS with additional arrays. So time complexity is same as DFS which is O(V+E) for adjacency list representation of graph."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"connected components")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"A connected component or simply component of an undirected graph is a subgraph in which each pair of nodes is connected with each other via a path."),i.a.createElement("li",null,"A set of nodes forms a connected component in an undirected graph if any node from the set of nodes can reach any other node by traversing edges. The main point here is reachability.",i.a.createElement("br",null),"In connected components, all the nodes are always reachable from each other."),i.a.createElement("li",null,i.a.createElement("img",{src:"https://www.baeldung.com/wp-content/uploads/sites/4/2020/05/1-component-1.png",className:"mx-auto img-fluid"})),i.a.createElement("li",null,"graph G1(V, E). Here V = ","{V1, V2, V3, V4, V5, V6}"," denotes the vertex set and E = ","{E1, E2, E3, E4, E5, E6, E7}"," denotes the edge set of G1. The graph G1 has one connected component, let\u2019s name it C1, which contains all the vertices of G1. Now let\u2019s check whether the set C1 holds to the definition or not."),i.a.createElement("li",null,"According to the definition, the vertices in the set C1 should reach one another via a path. We\u2019re choosing two random vertices V1 and V6:"),i.a.createElement("li",null,"V6 is reachable to V1 via: E4rightarrow E7 or E3rightarrow E5rightarrow E7 orE1rightarrow E2rightarrow E6rightarrow E7",i.a.createElement("br",null),"V1 is reachable to V6 via: E7rightarrow E4 or E7rightarrow E5rightarrow E3 orE7rightarrow E6\\rightarrow E2rightarrow E1"),i.a.createElement("li",null,"The vertices V1 and V6 satisfied the definition, and we could do the same with other vertex pairs in C1 as well"),i.a.createElement("li",null,"Algorithm for finding connected components in a given undirected graph uses the DFS search and counts the number of calls to the DFS function. If the graph is represented by the adjacency list, then the DFS search visits all the vertices once and each edge twice in case of an undirected graph. The checking of the vertex status takes O(1) time. Thus in total, our algorithm will take ","O(V+E)}"," time.",i.a.createElement("br",null),"In case the graph is represented by the adjacency matrix, the DFS search takes O(V^2) time as it needs to traverse the entire row to evaluate the neighbor vertices. The checking of the vertex status again takes O(1) time. Thus giving us a total of ","{O(V^2)}"," time.")))))))))},fe=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," Backtracking Algorithms"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction of Backtracking")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"The Backtracking is an algorithmic-method to solve a problem with an additional way. It uses a recursive approach to explain the problems. We can say that the backtracking is needed to find all possible combination to solve an optimization problem."),i.a.createElement("li",null,'Backtracking is a systematic way of trying out different sequences of decisions until we find one that "works."'),i.a.createElement("li",null,"Backtracking algorithm determines the solution by systematically searching the solution space for the given problem. Backtracking is a depth-first search with any bounding function. All solution using backtracking is needed to satisfy a complex set of constraints. The constraints may be explicit or implicit."),i.a.createElement("li",null,"Explicit Constraint is ruled, which restrict each vector element to be chosen from the given set."),i.a.createElement("li",null,"Implicit Constraint is ruled, which determine which each of the tuples in the solution space, actually satisfy the criterion function."),i.a.createElement("li",null,'Backtracking can understand of as searching a tree for a particular "goal" leaf node. Backtracking is undoubtedly quite simple - we "explore" each node, as follows:'),i.a.createElement("li",null,i.a.createElement("code",null,'To "explore" node N: ',i.a.createElement("br",null),'1. If N is a goal node, return "success"',i.a.createElement("br",null),'2. If N is a leaf node, return "failure"',i.a.createElement("br",null),"3. For each child C of N,",i.a.createElement("br",null),"Explore C",i.a.createElement("br",null),'If C was successful, return "success"',i.a.createElement("br",null),'4. Return "failure"',i.a.createElement("br",null))),i.a.createElement("li",null,i.a.createElement("img",{src:"data:image/jpeg;base64,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",className:"mx-auto img-fluid"})))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:6},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"All the possibilities")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"https://cdn.programiz.com/sites/tutorial2program/files/ba-possibilities.png",className:"mx-auto img-fluid mb-10"}),i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("strong",null," Problem:")," You want to find all the possible ways of arranging 2 boys and 1 girl on 3 benches. Constraint: Girl should not be on the middle bench.",i.a.createElement("br",null),i.a.createElement("br",null)),i.a.createElement("li",null,i.a.createElement("strong",null,"   Solution: "),"There are a total of 3! = 6 possibilities. We will try all the possibilities and get the possible solutions. We recursively try all the possibilities."),i.a.createElement("br",null),i.a.createElement("li",null,"It uses a brute force approach for finding the desired output. The Brute force approach tries out all the possible solutions and chooses the desired/best solutions."),i.a.createElement("li",null,"Here algorithm propagates to an end to check if it is a solution or not, if it is then returns the solution otherwise backtracks to the point one step behind it to find track to the next point to find solution.")))))),i.a.createElement(x.a,{md:6},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"State Space Tree")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"https://cdn.programiz.com/sites/tutorial2program/files/ba-state-state-tree-example.png",className:"mx-auto img-fluid"})))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Branch And Bound")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Branch and bound is an algorithm design paradigm which is generally used for solving combinatorial optimization problems. These problems are typically exponential in terms of time complexity and may require exploring all possible permutations in worst case. The Branch and Bound Algorithm technique solves these problems relatively quickly."),i.a.createElement("li",null,"A branch-and-bound algorithm consists of a systematic enumeration of candidate solutions by means of state space search: the set of candidate solutions is thought of as forming a rooted tree with the full set at the root. The algorithm explores branches of this tree, which represent subsets of the solution set. Before enumerating the candidate solutions of a branch, the branch is checked against upper and lower estimated bounds on the optimal solution, and is discarded if it cannot produce a better solution than the best one found so far by the algorithm."),i.a.createElement("li",null,"The algorithm depends on efficient estimation of the lower and upper bounds of regions/branches of the search space. If no bounds are available, the algorithm degenerates to an exhaustive search."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"0/1 Knapsack problem with Branch And Bound ")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("strong",null,"Knapsack Problem:"),"Given two arrays v[] and w[] that represent values and weights associated with n items respectively. Find out the maximum value subset(Maximum Profit) of v[] such that sum of the weights of this subset is smaller than or equal to Knapsack capacity Cap(W)."),i.a.createElement("li",null,"The backtracking based solution works better than brute force by ignoring infeasible solutions. To do better (than backtracking) if we know a bound on best possible solution subtree rooted with every node. If the best in subtree is worse than current best, we can simply ignore this node and its subtrees. So we compute bound (best solution) for every node and compare the bound with current best solution before exploring the node."),i.a.createElement("li",null,"To find bound for every node for Knapsack:",i.a.createElement("br",null),"To check if a particular node can give us a better solution or not, we compute the optimal solution (through the node) using Greedy method. If the solution computed by Greedy approach is more than the best until now , then we can\u2019t get a better solution through the node."),i.a.createElement("br",null),i.a.createElement("li",null,i.a.createElement("strong",null,"Algorithm:"),i.a.createElement("br",null),"Sort all items in decreasing order of V/W so that upper bound can be computed using Greedy Approach.(The nodes taken in the image are accordingly.)"),i.a.createElement("li",null,"Initialize profit, max = 0"),i.a.createElement("li",null,"Create an empty queue, Q."),i.a.createElement("li",null,"Create a dummy node of decision tree and enqueue it to Q. Profit and weight of dummy node are 0."),i.a.createElement("li",null,"Do while (Q is not empty).")),i.a.createElement("ul",null,i.a.createElement("li",null,"Extract an item from Q. Let the item be x."),i.a.createElement("li",null,"Compute profit of next level node. If the profit is more than max, then update max. (Profit from root to this node (include this node))."),i.a.createElement("li",null,"Compute bound of next level node. If bound is more than max, then add next level node to Q.(Upper Bound of the maximum Profit in subtree of this node)"),i.a.createElement("li",null,"Consider the case when next level node is not considered as part of solution and add a node to queue with level as next, but weight and profit without considering next level nodes."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"https://miro.medium.com/max/740/1*xVh3Q_gPeZIndK8AWrD2Og.png",className:"mx-auto img-fluid"})))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Travelling Salseman Problem")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Given a set of cities and distance between every pair of cities, the problem is to find the shortest possible tour that visits every city exactly once and returns to the starting point."),i.a.createElement("li",null,"For example, consider the graph shown in figure on right side. A TSP tour in the graph is 0-1-3-2-0. The cost of the tour is 10+25+30+15 which is 80."),i.a.createElement("li",null,"the cost through a node includes two costs.",i.a.createElement("br",null),"1) Cost of reaching the node from the root (When we reach a node, we have this cost computed)",i.a.createElement("br",null),"2) Cost of reaching an answer from current node to a leaf (We compute a bound on this cost to decide whether to ignore subtree with this node or not).",i.a.createElement("br",null)),i.a.createElement("li",null,"In cases of a maximization problem, an upper bound tells us the maximum possible solution if we follow the given node. For example in 0/1 knapsack we used Greedy approach to find an upper bound.",i.a.createElement("br",null),"In cases of a minimization problem, a lower bound tells us the minimum possible solution if we follow the given node. For example, in Job Assignment Problem, we get a lower bound by assigning least cost job to a worker."),i.a.createElement("li",null,"Time Complexity: The worst case complexity of Branch and Bound remains same as that of the Brute Force clearly because in worst case, we may never get a chance to prune a node. Whereas, in practice it performs very well depending on the different instance of the TSP. The complexity also depends on the choice of the bounding function as they are the ones deciding how many nodes to be pruned."),i.a.createElement("li",null,i.a.createElement(O.a,{responsive:!0},i.a.createElement("tr",null,i.a.createElement("th",null,"Node"),i.a.createElement("th",null,"Least cost edges"),i.a.createElement("th",null,"Total cost")),i.a.createElement("tr",null,i.a.createElement("td",null,"0"),i.a.createElement("td",null,"(0, 1), (0, 2)"),i.a.createElement("td",null,"25")),i.a.createElement("tr",null,i.a.createElement("td",null,"1"),i.a.createElement("td",null,"(0, 1), (1, 3)"),i.a.createElement("td",null,"35")),i.a.createElement("tr",null,i.a.createElement("td",null,"2"),i.a.createElement("td",null,"(0, 2), (2, 3)"),i.a.createElement("td",null,"45")),i.a.createElement("tr",null,i.a.createElement("td",null,"3"),i.a.createElement("td",null,"(0, 3), (1, 3)"),i.a.createElement("td",null,"45")))),i.a.createElement("li",null,i.a.createElement("code",null,"Cost of a tour T = (1/2) * \u2211 (Sum of cost of two edges adjacent to u and in the tour T) ",i.a.createElement("br",null),"where u \u2208 V",i.a.createElement("br",null),"For every vertex u, if we consider two edges through it in T, and sum their costs.  The overall sum for all vertices would be twice of cost of tour T (We have considered every edge twice.)",i.a.createElement("br",null),"(Sum of two tour edges adjacent to u) ",">="," (sum of minimum weight two edges adjacent to u)",i.a.createElement("br",null),"Cost of any tour ",">=","  1/2) * \u2211 (Sum of cost of two minimum weight edges adjacent to u) ",i.a.createElement("br",null),"where u \u2208 V")),i.a.createElement("li",null,i.a.createElement("img",{src:"http://lcm.csa.iisc.ernet.in/dsa/img445.gif",className:"mx-auto img-fluid"})))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"8 Queen Problem Chessboard")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("img",{src:"data:image/png;base64,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",className:"mx-auto img-fluid mb-3"}),i.a.createElement("ul",null,i.a.createElement("li",null,"Let the chessboard squares is numbered as the indices of the two dimensional array a [1:n, 1:n], then every element on the same diagonal that runs from the upper left to lower right has the same row- column value."),i.a.createElement("li",null,"Also every element on the same diagonal that goes from the upper right to lower left has the same row + column value."),i.a.createElement("li",null,"Suppose two queen are placed at positions (i, j) and (k, l), then by the above they are on the same diagonal only if i - j=k-l or i + j=k + l."),i.a.createElement("li",null,"The first equation implies j - l=i - k"),i.a.createElement("li",null,"The second equation implies j-l=k - i"),i.a.createElement("li",null,"Therefore two queens lie on the same diagonal if and only if j-l=i-k."),i.a.createElement("li",null,"Algorithm1: (Can a new queen be placed?)",i.a.createElement("br",null),i.a.createElement("code",null,"Algorithm Place(k, i)",i.a.createElement("br",null),"//Returns true if a queen can be placed in kth row and ith column otherwise it // returns //false. x [] is a global array whose first (k-1) value have been set.",i.a.createElement("br",null),"//Abs(r) returns the absolute value of r.",i.a.createElement("br",null),"{",i.a.createElement("br",null),"For j:= 1 to k-1 do",i.a.createElement("br",null),"If(x[j]=i) //Two in the same column",i.a.createElement("br",null),"Or (Abs x[j]-i) = Abs(j-k))",i.a.createElement("br",null),"//or in the same diagonal",i.a.createElement("br",null),"Then return false;",i.a.createElement("br",null),"Return true;",i.a.createElement("br",null),"}",i.a.createElement("br",null))),i.a.createElement("li",null,"Above algorithm palce (k,i) returns a Boolean value that is true if the kth queen can be placed in column i.",i.a.createElement("br",null),"It tests both whether I is distinct from all previous values x [1]\u2026\u2026..x[k-1] and whether there is no other queen on the same diagonal.",i.a.createElement("br",null),"It computing time O (k-1).",i.a.createElement("br",null),"The array x[] is a global",i.a.createElement("br",null),"The algorithm is invoked by N Queen (1, n).")),i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("strong",null,"Algorithm2: All solutions to the n-queen problems."),i.a.createElement("br",null)),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm N Queens(k, n)",i.a.createElement("br",null),"//Using backtracking this procedure prints all possible placements of a queen on",i.a.createElement("br",null),"//an n*n chessboard so that they are non-attacking",i.a.createElement("br",null),"{",i.a.createElement("br",null),"for i:= 1 to n do",i.a.createElement("br",null),"{",i.a.createElement("br",null),"If(Place(k,i)) then",i.a.createElement("br",null),"{",i.a.createElement("br",null),"x[k] := i;",i.a.createElement("br",null),"if(k=n) then write (x[1:n]);",i.a.createElement("br",null),"else N Queen(k+1,n);",i.a.createElement("br",null),"}","}","}")),i.a.createElement("li",null,"For an 8*8 chessboard there are (64/8) possible ways to place 8 pieces or approximate 4.4 billion 8-tuples to examine using brute force approach."),i.a.createElement("li",null,"However by allowing only placements of queens on distinct rows and columns, we require the examination of almost 8! Or only 40, 320, 8 tuples."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Knapsack Problem")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Given n positive weights wi, n positive profits pi , and a positive number M which is the knapsack capacity, the 0/1 knapsack problem calls for choosing a subset of the weights such that",i.a.createElement("br",null)," \u03a3",i.a.createElement("sub",null,"i = 1 to k "),"  w",i.a.createElement("sub",null,"i"),"x",i.a.createElement("sub",null,"i")," ","<="," M and",i.a.createElement("br",null)," \u03a3",i.a.createElement("sub",null,"i = 1 to k "),"  p",i.a.createElement("sub",null,"i"),"x",i.a.createElement("sub",null,"i")," is Maximized"),i.a.createElement("li",null,"The x's constitute a zero-one valued vector.",i.a.createElement("br",null),"The solution space for this problen consists of the 2n distinct ways to assign zero or one values to the x's.",i.a.createElement("br",null),"Thus the solution space is the same as that for the sum of the subsets problem."),i.a.createElement("li",null,"Bounding function is needed to help kill some live nodes without actually expanding them.",i.a.createElement("br",null),"A good bounding function for this problem is obtained by using an upper bound on the value of the best feasible solution obtainable by expanding the given live node and any of its descendants. If this upper bound is not higher than the value of the best solution determined so far then that live node may be killed."),i.a.createElement("li",null,"Here we use the fixed tuple size formulation.",i.a.createElement("br",null),"If at node Z the values of xi , 1 ","<="," i ","<="," k have already been determined, then an upper bound for Z can be obtained by relaxing the requirement xi = 0 or 1 to 0 ","<="," xi ","<="," 1 for k+1 ","<="," i ","<="," n and use the greedy method to solve the relaxed problem."),i.a.createElement("li",null,"Procedure Bound(p,w,k,M) determines an upper bound on the best solution obtainable by expanding any node Z at level k+1 of the state space tree"),i.a.createElement("li",null,i.a.createElement("code",null,"procedure BOUND(p,w,k,M) ",i.a.createElement("br",null),"// p: the current profit total",i.a.createElement("br",null),"// w: the current weight total",i.a.createElement("br",null),"// k : the index of the last removed item",i.a.createElement("br",null),"// M : the knapsack size",i.a.createElement("br",null),"// the return result is a new profit",i.a.createElement("br",null),"global  n , P(1:n) , W(1:n)",i.a.createElement("br",null),"integer k, i l real b,c,p,w, M",i.a.createElement("br",null),"b := p ;  c := w",i.a.createElement("br",null),"for  i := k+1 to n do ",i.a.createElement("br",null),"c := c + W(i)",i.a.createElement("br",null),"if c ","<"," M then b := b + P(j)",i.a.createElement("br",null),"else  return (b + (1 - (c - M)/W(i))*P(i))",i.a.createElement("br",null),"endif",i.a.createElement("br",null),"repeat",i.a.createElement("br",null),"return (b)",i.a.createElement("br",null),"end BOUND")),i.a.createElement("li",null,i.a.createElement("img",{src:"https://media.geeksforgeeks.org/wp-content/uploads/tree-weight.jpg",className:"mx-auto img-fluid"})),i.a.createElement("li",null,"Item arr[] = {{2, 40}, {3.14, 50}, {1.98, 100},{5, 95}, {3, 30}};",i.a.createElement("br",null),"Knapsack Capacity W = 10",i.a.createElement("br",null),"Output: The maximum possible profit = 235")))))))))},ye=function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"}," String Matching Algorithms"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,'String Matching Algorithm is also called "String Searching Algorithm." This is a vital class of string algorithm is declared as "this is the method to find a place where one is several strings are found within the larger string.'),i.a.createElement("li",null,"Given a text array, T [1.....n], of n character and a pattern array, P [1......m], of m characters. The problems are to find an integer s, called valid shift where 0 \u2264 s ","<"," n-m and T [s+1......s+m] = P [1......m]. In other words, to find even if P in T, i.e., where P is a substring of T. The item of P and T are character drawn from some finite alphabet such as ","{0, 1} or {A, B .....Z, a, b..... z}.Given a string T [1......n], "," the substrings are represented as T [i......j] for some 0\u2264i \u2264 j\u2264n-1, the string formed by the characters in T from index i to index j, inclusive. This process that a string is a substring of itself (take i = 0 and j =m)."),i.a.createElement("li",null,"The proper substring of string T [1......n] is T [1......j] for some "," 0<i \u2264 j\u2264n-1. That is, we must have either i>0 or j < m-1."),i.a.createElement("li",null,i.a.createElement("ul",null,i.a.createElement("li",null,"Algorithms used for String Matching:",i.a.createElement("br",null),"There are different types of method is used to finding the string"),i.a.createElement("li",null,"The Naive String Matching Algorithm"),i.a.createElement("li",null,"The Rabin-Karp-Algorithm"),i.a.createElement("li",null,"Finite Automata"),i.a.createElement("li",null,"The Knuth-Morris-Pratt Algorithm"),i.a.createElement("li",null,"The Boyer-Moore Algorithm"))))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"The Naive String Matching Algorithm")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"The na\xefve approach tests all the possible placement of Pattern P [1.......m] relative to text T [1......n]. We try shift s = 0, 1.......n-m, successively and for each shift s. Compare T [s+1.......s+m] to P [1......m]."),i.a.createElement("li",null,"The na\xefve algorithm finds all valid shifts using a loop that checks the condition P [1.......m] = T [s+1.......s+m] for each of the n - m +1 possible value of s."),i.a.createElement("li",null,i.a.createElement("code",null,"NAIVE-STRING-MATCHER (T, P)",i.a.createElement("br",null),"1. n \u2190 length [T]",i.a.createElement("br",null),"2. m \u2190 length [P]",i.a.createElement("br",null),"3. for s \u2190 0 to n -m",i.a.createElement("br",null),"4. do if P [1.....m] = T [s + 1....s + m]",i.a.createElement("br",null),'5. then print "Pattern occurs with shift" s')),i.a.createElement("li",null,'Input:  txt[] = "THIS IS A TEST TEXT"',i.a.createElement("br",null),'pat[] = "TEST"',i.a.createElement("br",null),"Output: Pattern found at index 10",i.a.createElement("br",null),'Input:  txt[] =  "AABAACAADAABAABA"',i.a.createElement("br",null),'pat[] =  "AABA"',i.a.createElement("br",null),"Output: Pattern found at index 0",i.a.createElement("br",null),"Pattern found at index 9",i.a.createElement("br",null),"Pattern found at index 12"),i.a.createElement("li",null,'The best case occurs when the first character of the pattern is not present in text at all. txt[] = "AABCCAADDEE"; pat[] = "FAA"; The number of comparisons in best case is O(n).'),i.a.createElement("li",null,'The worst case of Naive Pattern Searching occurs in following scenarios. 1) When all characters of the text and pattern are same. txt[] = "AAAAAAAAAAAAAAAAAA"; pat[] = "AAAAA";'),i.a.createElement("li",null,'Worst case also occurs when only the last character is different. txt[] = "AAAAAAAAAAAAAAAAAB"; pat[] = "AAAAB";'),i.a.createElement("li",null,"The number of comparisons in the worst case is O(m*(n-m+1)). Although strings which have repeated characters are not likely to appear in English text, they may well occur in other applications (for example, in binary texts). The KMP matching algorithm improves the worst case to O(n)."),i.a.createElement("li",null,i.a.createElement("img",{src:"data:image/png;base64,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",className:"mx-auto img-fluid"})))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Robin-Karp Algorithm")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"The Rabin-Karp string matching algorithm calculates a hash value for the pattern, as well as for each M-character subsequences of text to be compared. If the hash values are unequal, the algorithm will determine the hash value for next M-character sequence."),i.a.createElement("li",null,"If the hash values are equal, the algorithm will analyze the pattern and the M-character sequence. In this way, there is only one comparison per text subsequence, and character matching is only required when the hash values match."),i.a.createElement("li",null,"Rabin Karp algorithm needs to calculate hash values for following strings.",i.a.createElement("br",null),"1) Pattern itself. ",i.a.createElement("br",null),"2) All the substrings of the text of length m."),i.a.createElement("li",null,"we need to efficiently calculate hash values for all the substrings of size m of text, we must have a hash function which has the following property. ",i.a.createElement("br",null),"Hash at the next shift must be efficiently computable from the current hash value and next character in text or we can say hash(txt[s+1 .. s+m]) must be efficiently computable from hash(txt[s .. s+m-1]) and txt[s+m] i.e., hash(txt[s+1 .. s+m])= rehash(txt[s+m], hash(txt[s .. s+m-1])) and rehash must be O(1) operation.",i.a.createElement("br",null),"The hash function suggested by Rabin and Karp calculates an integer value. The integer value for a string is the numeric value of a string."),i.a.createElement("li",null,"hash( txt[s+1 .. s+m] ) = ( d ( hash( txt[s .. s+m-1]) \u2013 txt[s]*h ) + txt[s + m] ) mod q ",i.a.createElement("br",null),"hash( txt[s .. s+m-1] ) : Hash value at shift s. ",i.a.createElement("br",null),"hash( txt[s+1 .. s+m] ) : Hash value at next shift (or shift s+1) ",i.a.createElement("br",null),"d: Number of characters in the alphabet ",i.a.createElement("br",null),"q: A prime number ",i.a.createElement("br",null),"h: d^(m-1)"),i.a.createElement("li",null,"Time Complexity:",i.a.createElement("br",null),"The average and best-case running time of the Rabin-Karp algorithm is O(n+m), but its worst-case time is O(nm).",i.a.createElement("br",null),"Worst case of Rabin-Karp algorithm occurs when all characters of pattern and text are same as the hash values of all the substrings of txt[] match with hash value of pat[]. For example pat[] = \u201cAAA\u201d and txt[] = \u201cAAAAAAA\u201d."),i.a.createElement("li",null,i.a.createElement("img",{src:"data:image/png;base64,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",className:"mx-auto img-fluid"})))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"String Matching with Finite Automata")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",{class:"points"},"A finite automaton ",i.a.createElement("strong",null,"M")," is a 5-tuple ",i.a.createElement("strong",null,"(Q, q",i.a.createElement("sub",null,"0"),",A,\u2211",i.a.createElement("sub",null,"\u03b4"),")"),", where",i.a.createElement("li",null,"Q is a finite set of ",i.a.createElement("strong",null,"states"),","),i.a.createElement("li",null,"q",i.a.createElement("sub",null,"0")," \u2208 Q is the ",i.a.createElement("strong",null,"start state"),","),i.a.createElement("li",null,"A \u2286 Q is a notable set of ",i.a.createElement("strong",null,"accepting states"),","),i.a.createElement("li",null,"\u2211 is a ",i.a.createElement("strong",null,"finite input alphabet"),","),i.a.createElement("li",null,"\u03b4 is a function from ",i.a.createElement("strong",null,"Q x \u2211")," into ",i.a.createElement("strong",null,"Q")," called the ",i.a.createElement("strong",null,"transition function")," of ",i.a.createElement("strong",null,"M"),"."),i.a.createElement("li",null,"The finite automaton starts in state ",i.a.createElement("strong",null,"q",i.a.createElement("sub",null,"0"))," and reads the characters of its input string one at a time. If the automaton is in state q and reads input character a, it moves from state q to state \u03b4 (q, a). Whenever its current state q is a member of A, the machine M has accepted the string read so far. An input that is not allowed is ",i.a.createElement("strong",null,"rejected"),". A finite automaton M induces a function \u2205 called the called the ",i.a.createElement("strong",null,"final-state function"),", from \u2211* to Q such that \u2205(w) is the state M ends up in after scanning the string w. Thus, M accepts a string w if and only if \u2205(w) \u2208 A."),i.a.createElement("li",null,"The function f is defined as",i.a.createElement("br",null),i.a.createElement("pre",null,"\u2205 (\u2208)=q",i.a.createElement("sub",null,"0"),i.a.createElement("br",null),"\u2205 (wa) = \u03b4 ((\u2205 (w), a) for w \u2208 \u2211*,a\u2208 \u2211)")),i.a.createElement("li",null,"The primary loop structure of FINITE- AUTOMATON-MATCHER implies that its running time on a text string of length n is O (n)."),i.a.createElement("li",null,i.a.createElement("img",{src:"data:image/png;base64,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",className:"mx-auto img-fluid"})),i.a.createElement("li",null,'Simulating this on the string "banananona", we get the sequence of states empty, empty, empty, "n", "na", "nan", "na", "nan", "nano", "nano", "nano". Since we end in state "nano", this string contains "nano" in it somewhere. By paying more careful attention to when we first entered state "nano", we can tell exactly where it occurs; it is also possible to modify the machine slightly and find all occurrences of the substring rather than just the first occurrence.'),i.a.createElement("li",null,"This Algorithm that takes something like O(m^3 + n) time: O(m^3) to build the state table described above, and O(n) to simulate it on the input file. There are two tricky points to the KMP algorithm. First, it uses an alternate representation of the state table which takes only O(m) space (the one above could take O(m^2)). And second, it uses a complicated loop to build the whole thing in O(m) time."))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"The Knuth-Morris-Pratt (KMP)Algorithm")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"Knuth-Morris and Pratt introduce a linear time algorithm for the string matching problem. A matching time of O (n) is achieved by avoiding comparison with an element of 'S' that have previously been involved in comparison with some element of the pattern 'p' to be matched. i.e., backtracking on the string 'S' never occurs"),i.a.createElement("li",null,"Knuth Morris Pratt (KMP) is an algorithm, which checks the characters from left to right. When a pattern has a sub-pattern appears more than one in the sub-pattern, it uses that property to improve the time complexity, also for in the worst case.",i.a.createElement("br",null),"The time complexity of KMP is O(n)."),i.a.createElement("li",null,"Components of KMP Algorithm:",i.a.createElement("br",null),i.a.createElement("ul",null,i.a.createElement("li",null,"1. The Prefix Function (\u03a0): The Prefix Function, \u03a0 for a pattern encapsulates knowledge about how the pattern matches against the shift of itself. This information can be used to avoid a useless shift of the pattern 'p.' In other words, this enables avoiding backtracking of the string 'S.'"),i.a.createElement("li",null,"2. The KMP Matcher: With string 'S,' pattern 'p' and prefix function '\u03a0' as inputs, find the occurrence of 'p' in 'S' and returns the number of shifts of 'p' after which occurrences are found."))),i.a.createElement("li",null,"The Prefix Function (\u03a0)",i.a.createElement("br",null),"Following pseudo code compute the prefix function, \u03a0:",i.a.createElement("br",null),i.a.createElement("code",null,"COMPUTE- PREFIX- FUNCTION (P)",i.a.createElement("br",null),"1. m \u2190length [P]  ",i.a.createElement("br",null),"2. \u03a0 [1] \u2190 0",i.a.createElement("br",null),"3. k \u2190 0",i.a.createElement("br",null),"4. for q \u2190 2 to m",i.a.createElement("br",null),"5. do while k ",">"," 0 and P [k + 1] \u2260 P [q]",i.a.createElement("br",null),"6. do k \u2190 \u03a0 [k]",i.a.createElement("br",null),"7. If P [k + 1] = P [q]",i.a.createElement("br",null),"8. then k\u2190 k + 1",i.a.createElement("br",null),"9. \u03a0 [q] \u2190 k",i.a.createElement("br",null),"10. Return \u03a0",i.a.createElement("br",null)))))))))))},Ae=a(228),ve=a.n(Ae),we=[{path:"/Basics_Algorithms",name:"Basics Of Algorithms",icon:"design-2_ruler-pencil",component:Z,layout:"/Algolyzer"},{path:"/analysis",name:"Analysis Of Algorithms",icon:"design-2_ruler-pencil",component:ae,layout:"/Algolyzer"},{path:"/Asymptotic_Notations",name:"Asymptotic Notations",icon:"design-2_ruler-pencil",component:le,layout:"/Algolyzer"},{path:"/Recurrence_Relations",name:"Recurrence Relations",icon:"design-2_ruler-pencil",component:re,layout:"/Algolyzer"},{path:"/Sorting_Algorithms",name:"Sorting Algorithms",icon:"design-2_ruler-pencil",component:ie,layout:"/Algolyzer"},{path:"/Heap_Sort_Algorithms",name:"Heap Sort Algorithms",icon:"design-2_ruler-pencil",component:oe,layout:"/Algolyzer"},{path:"/Divide&Conquer_Algorithm",name:"Divide & Conquer_Algorithm",icon:"design-2_ruler-pencil",component:se,layout:"/Algolyzer"},{path:"/Max-Min Problem",name:"Max-Min Problem",icon:"design-2_ruler-pencil",component:ce,layout:"/Algolyzer"},{path:"/Dynamic_Programming",name:"Dynamic Programming",icon:"design-2_ruler-pencil",component:me,layout:"/Algolyzer"},{path:"/Knapsack_Problem",name:"Knapsack Problem",icon:"design-2_ruler-pencil",component:ue,layout:"/Algolyzer"},{path:"/Matrix_Chain_Multiplication",name:"Matrix Chain Multiplication",icon:"design-2_ruler-pencil",component:he,layout:"/Algolyzer"},{path:"/Longest_Common_Subsequence ",name:"LCS",icon:"design-2_ruler-pencil",component:de,layout:"/Algolyzer"},{path:"/Greedy-Algorithm",name:"Greedy-Algorithm",icon:"design-2_ruler-pencil",component:Ee,layout:"/Algolyzer"},{path:"/Huffman-Algorithm",name:"Huffman-Algorithm",icon:"design-2_ruler-pencil",component:pe,layout:"/Algolyzer"},{path:"/Spanning-Tree",name:"Spanning Tree",icon:"design-2_ruler-pencil",component:ge,layout:"/Algolyzer"},{path:"/Graphs",name:"Graphs",icon:"design-2_ruler-pencil",component:be,layout:"/Algolyzer"},{path:"/BackTracking-Algorithms",name:"BackTracking-Algorithms",icon:"design-2_ruler-pencil",component:fe,layout:"/Algolyzer"},{path:"/StringMatching-Algorithms",name:"StringMatching-Algorithms",icon:"design-2_ruler-pencil",component:ye,layout:"/Algolyzer"},{path:"/NP_Completeness-Algorithms",name:"NP_Completeness-Algorithms",icon:"design-2_ruler-pencil",component:function(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(G,{size:"sm"}),i.a.createElement("div",{className:"content"},i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h2",{className:"title"},"NP-Completeness"))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Introduction")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"There are computational problems that can not be solved by algorithms even with unlimited time. For example Turing Halting problem (Given a program and an input, whether the program will eventually halt when run with that input, or will run forever). Alan Turing proved that general algorithm to solve the halting problem for all possible program-input pairs cannot exist. A key part of the proof is, Turing machine was used as a mathematical definition of a computer and program (Source Halting Problem)."),i.a.createElement("li",null,"P is set of problems that can be solved by a deterministic Turing machine in Polynomial time.",i.a.createElement("br",null),"The class P consists of those problems that are solvable in polynomial time, i.e. these problems can be solved in time O(nk) in worst-case, where k is constant. These problems are called tractable, while others are called intractable or superpolynomial.",i.a.createElement("br",null),"Formally, an algorithm is polynomial time algorithm, if there exists a polynomial p(n) such that the algorithm can solve any instance of size n in a time O(p(n)).",i.a.createElement("br",null),"Problem requiring \u03a9(n50) time to solve are essentially intractable for large n. Most known polynomial time algorithm run in time O(nk) for fairly low value of k.",i.a.createElement("br",null),i.a.createElement("br",null),"The advantages in considering the class of polynomial-time algorithms is that all reasonable deterministic single processor model of computation can be simulated on each other with at most a polynomial slow-d"),i.a.createElement("li",null,"NP is set of decision problems that can be solved by a Non-deterministic Turing Machine in Polynomial time. P is subset of NP (any problem that can be solved by deterministic machine in polynomial time can also be solved by non-deterministic machine in polynomial time). Informally, NP is set of decision problems which can be solved by a polynomial time via a \u201cLucky Algorithm\u201d, a magical algorithm that always makes a right guess among the given set of choices",i.a.createElement("br",null),"The class NP consists of those problems that are verifiable in polynomial time. NP is the class of decision problems for which it is easy to check the correctness of a claimed answer, with the aid of a little extra information. Hence, we aren\u2019t asking for a way to find a solution, but only to verify that an alleged solution really is correct.",i.a.createElement("br",null),"Every problem in this class can be solved in exponential time using exhaustive search."),i.a.createElement("li",null,"P versus NP",i.a.createElement("br",null),"Every decision problem that is solvable by a deterministic polynomial time algorithm is also solvable by a polynomial time non-deterministic algorithm.",i.a.createElement("br",null),"All problems in P can be solved with polynomial time algorithms, whereas all problems in NP - P are intractable.",i.a.createElement("br",null),"It is not known whether P = NP. However, many problems are known in NP with the property that if they belong to P, then it can be proved that P = NP.",i.a.createElement("br",null),"If P \u2260 NP, there are problems in NP that are neither in P nor in NP-Complete.",i.a.createElement("br",null),"The problem belongs to class P if it\u2019s easy to find a solution for the problem. The problem belongs to NP, if it\u2019s easy to check a solution that may have been very tedious to find.",i.a.createElement("br",null)),i.a.createElement("li",null,"NP-complete problems are the hardest problems in NP set.  A decision problem L is NP-complete if:",i.a.createElement("br",null),"1) L is in NP (Any given solution for NP-complete problems can be verified quickly, but there is no efficient known solution).",i.a.createElement("br",null),"2) Every problem in NP is reducible to L in polynomial time (Reduction is defined below).",i.a.createElement("br",null),"A problem is NP-Hard if it follows property 2 mentioned above, doesn\u2019t need to follow property 1. Therefore, NP-Complete set is also a subset of NP-Hard set.",i.a.createElement("br",null)),i.a.createElement("li",null,"Decision vs Optimization Problems NP-completeness applies to the realm of decision problems.  It was set up this way because it\u2019s easier to compare the difficulty of decision problems than that of optimization problems.   In reality, though, being able to solve a decision problem in polynomial time will often permit us to solve the corresponding optimization problem in polynomial time (using a polynomial number of calls to the decision problem). So, discussing the difficulty of decision problems is often really equivalent to discussing the difficulty of optimization problems. (Source Ref 2). For example, consider the vertex cover problem (Given a graph, find out the minimum sized vertex set that covers all edges). It is an optimization problem. Corresponding decision problem is, given undirected graph G and k, is there a vertex cover of size k?"),i.a.createElement("li",null,"NP-Hard: L is NP-hard if for all L' \u03f5 NP, L' \u2264p L. Thus if we can solve L in polynomial time, we can solve all NP problems in polynomial time.",i.a.createElement("br",null),"NP-Complete L is NP-complete if",i.a.createElement("br",null),"L \u03f5 NP and",i.a.createElement("br",null),"L is NP-hard",i.a.createElement("br",null),"If any NP-complete problem is solvable in polynomial time, then every NP-Complete problem is also solvable in polynomial time. Conversely, if we can prove that any NP-Complete problem cannot be solved in polynomial time, every NP-Complete problem cannot be solvable in polynomial time."),i.a.createElement("li",null,i.a.createElement("img",{src:"https://media.geeksforgeeks.org/wp-content/uploads/NP-Completeness-1.png",className:"mx-auto img-fluid"})))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Hamilton Problem")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,"To find a Hamiltonian cycle un graph \"G' is not a decision problem but is graph G Hamiltonian is a decision problem"),i.a.createElement("li",null,"In Hamiltonian problem graph G is accepted as input and it is asked to find a simple cycle in G that"),i.a.createElement("li",null,"visits each vertex of G exactly on and returns to its starting vertex. Such a cycle is called Hamiltonian"),i.a.createElement("li",null,"cycle. Let G= (V, E) be a connected graph with 'n' vertices. A HAMILTONIAN CYCLE is a round trip path along 'n' edges of G which every vertex once and returns to its starting position."),i.a.createElement("li",null,"If the Hamiltonian cycle begins at some vertex V1 belongs to G and the vertex are visited in the order of V1,V2.Vn+1,then the edges are in E,1","<=I<=n"," and the Vi are distinct except V1 and Vn+1 which are equal."),i.a.createElement("li",null,"Find Hamiltonian cycle for any type of graph using The backtracking algorithm .")),i.a.createElement("ul",null,"Procedure:",i.a.createElement("br",null),i.a.createElement("li",null,"Define a solution vector X(XI........Xn) where Xi represents the I visited vertex of the proposed cycle."),i.a.createElement("li",null,"Create a cost adjacency matrix for the given graph"),i.a.createElement("li",null,"The solution array initialized to all zeros except X (1) =1, because the cycle should start at vertex '1'"),i.a.createElement("li",null,"4 Now we have to find the second vertex to be visited in the cycle The vertex from 1 to n are included in the cycle one by one by checking 2 conditions,"),i.a.createElement("li",null,"I There should be a path from previous visited vertex to current vertex II The current vertex must be distinct and should not have been visited earlier"),i.a.createElement("li",null,"When these two conditions are satisfied the current vertex is included in the cycle, else the next"),i.a.createElement("li",null,"vertex is tried. 7. When the nth vertex is visited we have to check, is there any path from nth vertex to first 8 vertex",i.a.createElement("br",null),"If no path, the go back one step and after the previous visited node. 8. Repeat the above steps to generate possible Hamiltonian cycle"),i.a.createElement("li",null,"Let us assume that the graph G contains a hamiltonian path covering the V vertices of the graph starting at a random vertex say Vstart and ending at Vend, now since we connected all the vertices to an arbitrary new vertex Vnew in G\u2019."),i.a.createElement("li",null,"We extend the original Hamiltonian Path to a Hamiltonian Cycle by using the edges Vend to Vnew and Vnew to Vstart respectively. The graph G\u2019 now contains the closed cycle traversing all vertices once."),i.a.createElement("li",null,"We assume that the graph G\u2019 has a Hamiltonian Cycle passing through all the vertices, inclusive of Vnew. Now to convert it to a Hamiltonian Path, we remove the edges corresponding to the vertex Vnew in the cycle. The resultant path will cover the vertices V of the graph and will cover them exactly once."),i.a.createElement("li",null,i.a.createElement("img",{src:"https://media.geeksforgeeks.org/wp-content/uploads/20200514160443/Copy-of-Untitled-Diagram-3-1.jpg",className:"mx-auto img-fluid"})),i.a.createElement("li",null,"we can say that the graph G\u2019 contains a Hamiltonian Cycle iff graph G contains a Hamiltonian Path. Therefore, any instance of the Hamiltonian Cycle problem can be reduced to an instance of the Hamiltonian Path problem. Thus, the Hamiltonian Cycle is NP-Hard."),i.a.createElement("li",null,"Conclusion: Since, the Hamiltonian Cycle is both, a NP-Problem and NP-Hard. Therefore, it is a NP-Complete problem."),i.a.createElement("li",null,i.a.createElement("code",null,"Algorithm (Finding all Hamiltonian cycle) ",i.a.createElement("br",null),i.a.createElement("strong",null,"Algorithm Hamiltonian (k)",i.a.createElement("br",null)),"{",i.a.createElement("br",null),"Loop",i.a.createElement("br",null),"Next value (k) If (x (k)-0) then return",i.a.createElement("br",null),"If ken then",i.a.createElement("br",null),"{",i.a.createElement("br",null),"Print (*) Else",i.a.createElement("br",null),"Hamiltonian (k-1);",i.a.createElement("br",null),"End If","}",i.a.createElement("br",null),"Repeat",i.a.createElement("br",null),"}",i.a.createElement("br",null),i.a.createElement("br",null),i.a.createElement("strong",null,"Algorithm Nextvalue (1)"),i.a.createElement("br",null),"{","Repeat",i.a.createElement("br",null),"{","(k]-(X []+1) mod (n+1): //next vertex If (X [k]-0) then return",i.a.createElement("br",null),"If (G X (k 11 X (l 0) then",i.a.createElement("br",null),"{","for 1 to k-1 do if (X[j]= x[k]) then break // Check for distinction ",i.a.createElement("br",null),"If (j==k)) then // If true then the vertex is distinct (ken) or (l )d GPX Ink X[] then return",i.a.createElement("br",null),"if((k","<","n)or(k=n) and G[x[n],x[1]]!=0)) then return",i.a.createElement("br",null),"}",i.a.createElement("br",null),"}","Until (false)",i.a.createElement("br",null),"}")))))))),i.a.createElement(w.a,null,i.a.createElement(x.a,{md:12},i.a.createElement(k.a,{style:{padding:"5px"}},i.a.createElement(T.a,null,i.a.createElement("h5",{className:"title"},"Travelling Salesman problem")),i.a.createElement(M.a,{className:"all-icons"},i.a.createElement(w.a,null,i.a.createElement("ul",null,i.a.createElement("li",null,'For the partition problem, the sum of subset problem and the satisfiability problem there are either yes" or "no" They are called decision problems The minimal spanning tree problem and the traveling salesperson problem are called option problems For an optimization problem, there always a decision problem componding \u2022 For instance, consider the minimal spanning tree problem we can define decision version of it'),i.a.createElement("li",null,'Given a graph G, determine whether there exists a spanning tree of G whose total length a len than Even constant This decision version of the minimal spanning tree can be solved are the n spenning tree problem, which is an optimization problem, is solved. m l \u2022 Suppose the total length of the minimal spanning tree sa fac the answer is "yes otherwise',i.a.createElement("br",null),"answer is no The decision version of this minimal spanning tree problems which ia an optimization problem is solved."),i.a.createElement("li",null,"we can define the longest common subsequence decision problem as follows",i.a.createElement("br",null),"Given two sequences determine whether there exists a common subsequence of them whome length is greater than a given constant e We again call this decision problem the longest common subsequence decision problem The decision venson problem will be solved a s the optimization problem is solved In general optimization problems are more difficult than decision problems",i.a.createElement("br",null),"To investigate whether an optimation problem is difficult to save its decision version is difficult or not. If the decision version is difficult already the options"),i.a.createElement("li",null,i.a.createElement("img",{src:ve.a,className:"mx-auto img-fluid"})),i.a.createElement("li",null,"Given a set of cities and the distance between each pair of cities, the travelling salesman problem finds the path between these cities such that it is the shortest path and traverses every city once, returning back to the starting point."),i.a.createElement("li",null,"Every instance of the Hamiltonian Cycle problem consists of a graph G =(V, E) as the input can be converted to a Travelling Salesman problem consisting of graph G\u2019 = (V\u2019, E\u2019) and the maximum cost, K. We will construct the graph G\u2019 in the following way: For all the edges e belonging to E, add the cost of edge c(e)=1. Connect the remaining edges, e\u2019 belonging to E\u2019, that are not present in the original graph G, each with a cost c(e\u2019)= 2. And, set K = N."),i.a.createElement("li",null,"The new graph G\u2019 can be constructed in polynomial time by just converting G to a complete graph G\u2019 and adding corresponding costs. This reduction can be proved by the following two claims:"),i.a.createElement("li",null,"Let us assume that the graph G contains a Hamiltonian Cycle, traversing all the vertices V of the graph. Now, these vertices form a TSP with cost = N Since it uses all the edges of the original graph having cost c(e)=1. And, since it is a cycle, therefore, it returns back to the original vertex."),i.a.createElement("li",null,"We assume that the graph G\u2019 contains a TSP with cost, K = N. The TSP traverses all the vertices of the graph returning to the original vertex. Now since none of the vertices are excluded from the graph and the cost sums to n, therefore, necessarily it uses all the edges of the graph present in E, with cost 1, hence forming a hamiltonian cycle with the graph G."),i.a.createElement("li",null,"we can say that the graph G\u2019 contains a TSP if graph G contains Hamiltonian Cycle. Therefore, any instance of the Travelling salesman problem can be reduced to an instance of the hamiltonian cycle problem. Thus, the TSP is NP-Hard.")))))))))},layout:"/Algolyzer"}],xe=function(e){Object(d.a)(a,e);var t=Object(E.a)(a);function a(){var e;Object(u.a)(this,a);for(var l=arguments.length,n=new Array(l),r=0;r<l;r++)n[r]=arguments[r];return(e=t.call.apply(t,[this].concat(n))).state={isOpen:!1,dropdownOpen:!1,color:"transparent"},e.sidebarToggle=i.a.createRef(),e.toggle=function(){e.state.isOpen?e.setState({color:"transparent"}):e.setState({color:"white"}),e.setState({isOpen:!e.state.isOpen})},e.dropdownToggle=function(t){e.setState({dropdownOpen:!e.state.dropdownOpen})},e.getBrand=function(){var t;return we.map((function(a,l){return a.collapse?a.views.map((function(a,l){return a.path===e.props.location.pathname&&(t=a.name),null})):(a.redirect,a.path===e.props.location.pathname&&(t=a.name)),null})),t},e.openSidebar=function(){document.documentElement.classList.toggle("nav-open"),e.sidebarToggle.current.classList.toggle("toggled")},e.updateColor=function(){window.innerWidth<993&&e.state.isOpen?e.setState({color:"white"}):e.setState({color:"transparent"})},e}return Object(h.a)(a,[{key:"componentDidMount",value:function(){window.addEventListener("resize",this.updateColor.bind(this))}},{key:"componentDidUpdate",value:function(e){window.innerWidth<993&&e.history.location.pathname!==e.location.pathname&&-1!==document.documentElement.className.indexOf("nav-open")&&(document.documentElement.classList.toggle("nav-open"),this.sidebarToggle.current.classList.toggle("toggled"))}},{key:"render",value:function(){var e=this;return i.a.createElement(g.a,{color:-1!==this.props.location.pathname.indexOf("full-screen-maps")?"white":this.state.color,expand:"lg",className:-1!==this.props.location.pathname.indexOf("full-screen-maps")?"navbar-absolute fixed-top":"navbar-absolute fixed-top "+("transparent"===this.state.color?"navbar-transparent ":"")},i.a.createElement(b.a,{fluid:!0},i.a.createElement("div",{className:"navbar-wrapper"},i.a.createElement("div",{className:"navbar-toggle"},i.a.createElement("button",{type:"button",ref:this.sidebarToggle,className:"navbar-toggler",onClick:function(){return e.openSidebar()}},i.a.createElement("span",{className:"navbar-toggler-bar bar1"}),i.a.createElement("span",{className:"navbar-toggler-bar bar2"}),i.a.createElement("span",{className:"navbar-toggler-bar bar3"}))),i.a.createElement(f.a,{href:"/"},this.getBrand())),i.a.createElement(y.a,{onClick:this.toggle},i.a.createElement("span",{className:"navbar-toggler-bar navbar-kebab"}),i.a.createElement("span",{className:"navbar-toggler-bar navbar-kebab"}),i.a.createElement("span",{className:"navbar-toggler-bar navbar-kebab"})),i.a.createElement(A.a,{isOpen:this.state.isOpen,navbar:!0,className:"justify-content-end"})))}}]),a}(i.a.Component),ke=function(e){Object(d.a)(a,e);var t=Object(E.a)(a);function a(){return Object(u.a)(this,a),t.apply(this,arguments)}return Object(h.a)(a,[{key:"render",value:function(){return i.a.createElement("footer",{className:"footer"+(this.props.default?" footer-default":"")},i.a.createElement(b.a,{fluid:!!this.props.fluid},i.a.createElement("nav",null,i.a.createElement("ul",null,i.a.createElement("li",null))),i.a.createElement("div",{className:"copyright"},"\xa9 ",1900+(new Date).getYear(),", Developed by"," ","& ","Maintained by"," ",i.a.createElement("a",{href:"https://github.com/vipashaaV321",target:"_blank",rel:"noopener noreferrer"},"Vipasha Vaghela"))))}}]),a}(i.a.Component),Te=a(181),Ne=function(e){Object(d.a)(a,e);var t=Object(E.a)(a);function a(e){var l;return Object(u.a)(this,a),(l=t.call(this,e)).activeRoute.bind(Object(H.a)(l)),l}return Object(h.a)(a,[{key:"activeRoute",value:function(e){return this.props.location.pathname.indexOf(e)>-1?"active":""}},{key:"componentDidMount",value:function(){navigator.platform.indexOf("Win")>-1&&(l=new p.a(this.refs.sidebar,{suppressScrollX:!0,suppressScrollY:!1}))}},{key:"componentWillUnmount",value:function(){navigator.platform.indexOf("Win")>-1&&l.destroy()}},{key:"render",value:function(){var e=this;return i.a.createElement("div",{className:"sidebar","data-color":this.props.backgroundColor},i.a.createElement("div",{className:"logo",style:{color:"#fff",textAlign:"center"}},i.a.createElement(c.c,{className:"nav-link",style:{textDecoration:"none",color:"#fff"},to:"/"},i.a.createElement("h4",null,"Algolyzer"))),i.a.createElement("div",{className:"sidebar-wrapper",ref:"sidebar"},i.a.createElement(Te.a,null,this.props.routes.map((function(t,a){return t.redirect?null:i.a.createElement("li",{className:e.activeRoute(t.layout+t.path)+(t.pro?" active active-pro":""),key:a},i.a.createElement(c.c,{to:t.layout+t.path,className:"nav-link",activeClassName:"active"},i.a.createElement("i",{className:"now-ui-icons "+t.icon}),i.a.createElement("p",null,t.name)))})))))}}]),a}(i.a.Component),Ie=function(e){Object(d.a)(a,e);var t=Object(E.a)(a);function a(){var e;Object(u.a)(this,a);for(var l=arguments.length,n=new Array(l),r=0;r<l;r++)n[r]=arguments[r];return(e=t.call.apply(t,[this].concat(n))).state={backgroundColor:"blue"},e.mainPanel=i.a.createRef(),e.handleColorClick=function(t){e.setState({backgroundColor:t})},e}return Object(h.a)(a,[{key:"componentDidMount",value:function(){navigator.platform.indexOf("Win")>-1&&(n=new p.a(this.mainPanel.current),document.body.classList.toggle("perfect-scrollbar-on"))}},{key:"componentWillUnmount",value:function(){navigator.platform.indexOf("Win")>-1&&(n.destroy(),document.body.classList.toggle("perfect-scrollbar-on"))}},{key:"componentDidUpdate",value:function(e){"PUSH"===e.history.action&&(document.documentElement.scrollTop=0,document.scrollingElement.scrollTop=0,this.mainPanel.current.scrollTop=0)}},{key:"render",value:function(){return i.a.createElement("div",{className:"wrapper"},i.a.createElement(Ne,Object.assign({},this.props,{routes:we,backgroundColor:this.state.backgroundColor})),i.a.createElement("div",{className:"main-panel",ref:this.mainPanel},i.a.createElement(xe,this.props),i.a.createElement(m.d,null,we.map((function(e,t){return i.a.createElement(m.b,{path:e.layout+e.path,component:e.component,key:t})})),i.a.createElement(m.a,{from:"/Algolyzer",to:"Algolyzer/Basics_Algorithms"})),i.a.createElement(ke,{fluid:!0})))}}]),a}(i.a.Component);s.a.render(i.a.createElement(i.a.StrictMode,null,i.a.createElement(c.a,null,i.a.createElement(m.d,null,i.a.createElement(m.b,{path:"/home",render:function(e){return i.a.createElement($,e)}}),i.a.createElement(m.b,{path:"/Algolyzer",render:function(e){return i.a.createElement(Ie,e)}}),i.a.createElement(m.a,{to:"/home"})))),document.getElementById("root"))}},[[231,1,2]]]);
//# sourceMappingURL=main.c5ddd78f.chunk.js.map